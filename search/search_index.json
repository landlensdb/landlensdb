{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"landlensdb Documentation","text":"<p>Geospatial image handling and management with Python and PostgreSQL</p>"},{"location":"#overview","title":"Overview","text":"<p><code>landlensdb</code> helps you manage geolocated images and integrate them with other spatial data sources. The library supports:</p> <ul> <li>Image downloading and storage</li> <li>EXIF/geotag extraction</li> <li>Road-network alignment</li> <li>PostgreSQL integration</li> </ul> <p>This library is designed to support workflows process large sets of georeferenced images.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>GeoImageFrame: Download, map, and convert geolocated images into a GeoDataFrame-like structure.</li> <li>Mapillary API Integration: Fetch and analyze images with geospatial metadata.</li> <li>EXIF Data Processing: Extract geolocation, timestamps, and orientation from image metadata.</li> <li>Database Operations: Store image records in PostgreSQL; retrieve them by location or time.</li> <li>Road Network Alignment: Snap image captures to road networks for precise route mapping.</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>The examples below are Jupyter notebooks and can help you get started!</p> <ul> <li>Getting Started: DTM and CHM</li> <li>Calculating Forest Metrics</li> <li>Working with Large Point Clouds</li> </ul> <p>To install Jupyter, you can use conda or pip, with either:</p> <pre><code>conda install jupyter\n</code></pre> <p>or</p> <pre><code>pip install jupyter\n</code></pre>"},{"location":"#attribution","title":"Attribution","text":""},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting ipercival[at]gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"contributing/","title":"Contributing to landlensdb","text":"<p>Thank you for contributing to landlensdb! Your involvement helps make this project a great tool for point cloud data processing and visualization of forest structure.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>By participating in this project, please follow our Code of Conduct.</p>"},{"location":"contributing/#how-can-i-contribute","title":"How Can I Contribute?","text":""},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":"<ul> <li> <p>Check Existing Issues \u2014 Before opening a new bug report, see if the issue has already been reported. If it has, add any additional details in a comment.</p> </li> <li> <p>Submit a Report \u2014 If the issue hasn't been reported, open a new issue and fill out the provided template.</p> </li> </ul>"},{"location":"contributing/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>Have an idea to improve landlensdb? Please open an issue to discuss your suggestion.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>To contribute via pull requests:</p> <ol> <li>Fork the Repository \u2014 Fork the landlensdb repository and clone it locally.</li> <li>Create a Branch \u2014 Make changes in a new branch. Use descriptive names like <code>feat/</code>, <code>fix/</code>, or <code>docs/</code> followed by the feature or fix name.</li> <li>Commit Your Changes \u2014 Write a clear commit message describing your changes.</li> <li>Push to Your Fork \u2014 Push the branch to your fork on GitHub.</li> <li>Create a Pull Request \u2014 Open a pull request (PR) in the landlensdb repository. Link any relevant issues.</li> <li>Code Review \u2014 A maintainer will review your changes. You may need to make updates based on feedback.</li> <li>Merge \u2014 Once approved, your PR will be merged into the main codebase.</li> </ol>"},{"location":"contributing/#style-guidelines","title":"Style Guidelines","text":""},{"location":"contributing/#python","title":"Python","text":"<ul> <li>Follow the PEP 8 style guide.</li> <li>Use type hints in functions.</li> <li>Add documentation to public APIs.</li> </ul>"},{"location":"contributing/#git-commit-messages","title":"Git Commit Messages","text":"<ul> <li>Use present tense (\"Add feature\" not \"Added feature\").</li> <li>Limit the first line to 72 characters or fewer.</li> <li>Reference related issues and PRs when relevant.</li> </ul>"},{"location":"contributing/#releasing-a-new-version","title":"Releasing a New Version","text":""},{"location":"contributing/#steps-for-creating-a-new-release","title":"Steps for Creating a New Release","text":"<ol> <li> <p>Ensure <code>main</code> is up to date:    Confirm all changes intended for the release are merged into the <code>main</code> branch.</p> </li> <li> <p>Update the version:    Manually bump the version number in <code>setup.py</code> based on the type of release (major, minor, or patch) following semantic versioning.</p> </li> <li> <p>Create a new tag:    Tag the release with the new version using the format <code>vX.X.X</code>. For example:    <pre><code>git tag v1.2.0\ngit push origin v1.2.0\n</code></pre></p> </li> <li> <p>Deploy to PyPI:    The GitHub Actions workflow will automatically build and deploy the package to PyPI once the tag is pushed.</p> </li> </ol>"},{"location":"contributing/#semantic-versioning-guidelines","title":"Semantic Versioning Guidelines","text":"<ul> <li>Major version: For incompatible API changes.</li> <li>Minor version: For backward-compatible features.</li> <li>Patch version: For backward-compatible bug fixes.</li> </ul>"},{"location":"contributing/#contributing-to-documentation","title":"Contributing to Documentation","text":"<p>Documentation uses <code>mkdocs</code>. Install dependencies using:</p> <pre><code>pip install -e .\"[docs]\"\n</code></pre> <p>Commit changes and deploy using:</p> <pre><code>mkdocs gh-deploy\n</code></pre>"},{"location":"contributing/#additional-notes","title":"Additional Notes","text":"<ul> <li>Ensure compatibility with the latest dependencies.</li> <li>Update documentation when adding or changing features.</li> </ul>"},{"location":"examples/","title":"Examples","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>landlensdb requires PostgreSQL (\u2265 14) and PostGIS (\u2265 3.5). You should also have Python \u2265 3.10. PostGIS is an extension that adds spatial types to PostgreSQL, enabling geospatial queries and storage.</p>"},{"location":"installation/#postgresql-and-postgis","title":"PostgreSQL and PostGIS","text":"<ol> <li>Using conda (recommended)</li> </ol> <pre><code>conda create -n landlensdb_env -c conda-forge postgresql postgis\nconda activate landlensdb_env\n</code></pre> <p>Remember to initialize and start the PostgreSQL server before using <code>landlensdb</code>. Once your database is up, enable PostGIS in your database:</p> <pre><code>CREATE EXTENSION postgis;\n</code></pre> <ol> <li>Using system packages (example: Ubuntu/Debian)</li> </ol> <pre><code>sudo apt-get update\nsudo apt-get install postgresql postgresql-contrib postgis\n</code></pre> <p>Then enable PostGIS in PostgreSQL as shown above.</p> <p>For more details on setup and configuration: - PostgreSQL docs - PostGIS docs</p>"},{"location":"installation/#installing-landlensdb","title":"Installing landlensdb","text":""},{"location":"installation/#from-pypi","title":"From PyPI","text":"<pre><code>pip install landlensdb\n</code></pre>"},{"location":"installation/#from-github","title":"From GitHub","text":"<p>Install the latest development version:</p> <pre><code>pip install git+https://github.com/landlensdb/landlensdb\n</code></pre>"},{"location":"installation/#docker","title":"Docker","text":"<p>A Docker environment with <code>landlensdb</code> can be provided as well. Adjust the Docker image and tag as needed:</p> <pre><code>docker run -it --rm -p 8888:8888 yourdockeruser/landlensdb:latest\n</code></pre>"},{"location":"api/geoclasses/","title":"GeoClasses API","text":""},{"location":"api/geoclasses/#geoimageframe","title":"GeoImageFrame","text":""},{"location":"api/geoclasses/#landlensdb.geoclasses.geoimageframe.GeoImageFrame","title":"<code>GeoImageFrame</code>","text":"<p>               Bases: <code>GeoDataFrame</code></p> <p>A GeoDataFrame extension for managing geolocated images.</p> <p>Attributes:</p> Name Type Description <code>image_url</code> <code>str</code> <p>URL to the image file.</p> <code>name</code> <code>str</code> <p>Name or label for the image.</p> <code>geometry</code> <code>Point</code> <p>Geolocation of the image.</p> Example <p>geo_frame = GeoImageFrame({'image_url': ['http://example.com/image.jpg'], 'name': ['Sample'], 'geometry': [Point(0, 0)]})</p> Source code in <code>landlensdb/geoclasses/geoimageframe.py</code> <pre><code>class GeoImageFrame(GeoDataFrame):\n    \"\"\"A GeoDataFrame extension for managing geolocated images.\n\n    Attributes:\n        image_url (str): URL to the image file.\n        name (str): Name or label for the image.\n        geometry (shapely.geometry.Point): Geolocation of the image.\n\n    Example:\n        geo_frame = GeoImageFrame({'image_url': ['http://example.com/image.jpg'], 'name': ['Sample'], 'geometry': [Point(0, 0)]})\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize the GeoImageFrame object.\n\n        Args:\n            *args: Positional arguments passed to the GeoDataFrame constructor.\n            **kwargs: Keyword arguments passed to the GeoDataFrame constructor.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._verify_structure()\n\n    def _verify_structure(self):\n        \"\"\"Verifies the structure of the GeoImageFrame to ensure it has the required columns and datatypes.\"\"\"\n        required_columns = {\"image_url\": str, \"name\": str, \"geometry\": Point}\n\n        for col, dtype in required_columns.items():\n            if col not in self.columns:\n                raise ValueError(f\"The required column '{col}' is missing.\")\n\n            # Check if the elements are of the correct type\n            wrong_type_mask = ~self[col].apply(lambda x: isinstance(x, dtype))\n            if wrong_type_mask.any():\n                raise TypeError(f\"Column '{col}' contains wrong data type.\")\n\n    def to_dict_records(self):\n        \"\"\"Converts the GeoImageFrame to a dictionary representation.\n\n        Returns:\n            list: List of dictionaries representing the GeoImageFrame rows.\n        \"\"\"\n        return self.to_dict(\"records\")\n\n    def to_file(self, filename, **kwargs):\n        \"\"\"Saves the GeoImageFrame to a file.\n\n        Args:\n            filename (str): The filename or path to save the GeoImageFrame.\n            **kwargs: Additional keyword arguments for the 'to_file' method.\n        \"\"\"\n        for col in self.columns:\n            if col != \"geometry\":\n                self[col] = self[col].apply(\n                    lambda x: x.wkt if isinstance(x, Point) else x\n                )\n\n        super().to_file(filename, **kwargs)\n\n    def to_postgis(self, name, engine, if_exists=\"fail\", *args, **kwargs):\n        \"\"\"Saves the GeoImageFrame to a PostGIS database.\n\n        Args:\n            name (str): Name of the table to create or update.\n            engine (sqlalchemy.engine.Engine): SQLAlchemy engine connected to the database.\n            if_exists (str): Behavior if the table already exists in the database. Default is \"fail\".\n            *args: Additional positional arguments for the 'to_postgis' method.\n            **kwargs: Additional keyword arguments for the 'to_postgis' method.\n\n        Raises:\n            ValueError: If required columns are missing or if the CRS is incorrect.\n            TypeError: If the columns contain incorrect data types.\n        \"\"\"\n        required_columns = [\"name\", \"image_url\", \"geometry\"]\n        for col in required_columns:\n            if col not in self.columns:\n                raise ValueError(f\"Column '{col}' is missing.\")\n\n        if not self[\"name\"].apply(isinstance, args=(str,)).all():\n            raise TypeError(\"All entries in 'name' column must be of type string.\")\n\n        if not self[\"image_url\"].apply(isinstance, args=(str,)).all():\n            raise TypeError(\"All entries in 'image_url' column must be of type string.\")\n\n        if self[\"image_url\"].duplicated().any():\n            raise ValueError(\n                \"'image_url' column has duplicate entries. It must be unique.\"\n            )\n\n        if not all(geom.geom_type == \"Point\" for geom in self[\"geometry\"]):\n            raise TypeError(\"All geometries must be of type Point.\")\n\n        if self.crs != \"EPSG:4326\":\n            raise ValueError(\"CRS must be EPSG:4326.\")\n\n        metadata = MetaData()\n        metadata.reflect(bind=engine)\n\n        if not inspect(engine).has_table(name):\n            super().to_postgis(name, engine, if_exists=if_exists, *args, **kwargs)\n        else:\n            if if_exists == \"fail\":\n                raise ValueError(f\"Table '{name}' already exists.\")\n            elif if_exists == \"replace\":\n                table = metadata.tables[name]\n                with engine.connect() as conn:\n                    table.drop(conn)\n                super().to_postgis(name, engine, if_exists=\"replace\", *args, **kwargs)\n\n            elif if_exists == \"append\":\n                super().to_postgis(name, engine, if_exists=\"append\", *args, **kwargs)\n\n        metadata.reflect(bind=engine)\n        table = metadata.tables[name]\n\n        with engine.connect() as conn:\n            for col in required_columns:\n                stmt = text(f\"ALTER TABLE {table.name} ALTER COLUMN {col} SET NOT NULL\")\n                conn.execute(stmt)\n\n            constraint_name = f\"{table.name}_image_url_key\"\n\n            stmt = text(\n                f\"ALTER TABLE {table.name} \"\n                f\"ADD CONSTRAINT {constraint_name} UNIQUE (image_url)\"\n            )\n            conn.execute(stmt)\n            conn.connection.commit()\n\n    @staticmethod\n    def _download_image_from_url(\n        url: str,\n        dest_path: str,\n        max_retries: int = 3,\n        retry_delay: int = 1\n    ) -&gt; str | None:\n        \"\"\"Internal method to download an image from a URL with retries.\n\n        Args:\n            url: The URL of the image to download.\n            dest_path: The destination path to save the downloaded image.\n            max_retries: Maximum number of retry attempts.\n            retry_delay: Delay between retries in seconds.\n\n        Returns:\n            The local path where the image was downloaded, or None if failed.\n        \"\"\"\n        from time import sleep\n\n        for attempt in range(max_retries):\n            try:\n                response = requests.get(url, stream=True)\n                response.raise_for_status()\n\n                with open(dest_path, \"wb\") as f:\n                    for chunk in response.iter_content(chunk_size=8192):\n                        if chunk:  # Filter out keep-alive chunks\n                            f.write(chunk)\n\n                return dest_path\n\n            except requests.RequestException as e:\n                if attempt &lt; max_retries - 1:\n                    msg = (\n                        f\"Attempt {attempt + 1} failed downloading {url}. \"\n                        f\"Error: {e}. Retrying...\"\n                    )\n                    print(msg)\n                    sleep(retry_delay)\n                else:\n                    msg = (\n                        f\"Failed to download {url} after {max_retries} \"\n                        f\"attempts. Error: {e}\"\n                    )\n                    print(msg)\n\n        return None\n\n    def download_images_to_local(self, dest_dir, filename_column=None, max_workers=10):\n        \"\"\"\n        Downloads the images specified in the 'image_url' column of the GeoDataFrame to a local directory using multiple threads.\n\n        Args:\n            dest_dir (str): The destination directory where the images will be downloaded.\n            filename_column (str, optional): Column to use for the filename. Defaults to the filename in the URL.\n            max_workers (int, optional): Maximum number of concurrent download threads. Defaults to 10.\n\n        Returns:\n            GeoImageFrame: A new GeoImageFrame with the local paths to the downloaded images.\n\n        Example:\n            local_gdf = geo_image_frame.download_images_to_local('images/', max_workers=20)\n        \"\"\"\n        import os\n        from concurrent.futures import ThreadPoolExecutor, as_completed\n\n        if \"image_url\" not in self.columns:\n            raise ValueError(\"The GeoImageFrame must have a column named 'image_url'.\")\n\n        # Create destination directory if it doesn't exist\n        os.makedirs(dest_dir, exist_ok=True)\n\n        gdf_copy = self.copy()\n        download_tasks = []\n\n        # Prepare download tasks\n        for index, row in gdf_copy.iterrows():\n            image_url = row[\"image_url\"]\n\n            # Skip placeholder URLs\n            if image_url.startswith(\"placeholder://\"):\n                print(f\"Skipping placeholder URL: {image_url}\")\n                continue\n\n            # Skip non-HTTP URLs\n            if not image_url.startswith((\"http://\", \"https://\")):\n                print(f\"Skipping {image_url}. It's not a valid URL.\")\n                continue\n\n            original_filename = image_url.split(\"/\")[-1].split(\".\")[0]\n            filename_value = row.get(filename_column, original_filename)\n            destination_path = os.path.join(dest_dir, f\"{filename_value}.jpg\")\n\n            download_tasks.append((index, image_url, destination_path))\n\n        # Download images using thread pool\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            futures = {\n                executor.submit(self._download_image_from_url, url, dest_path): (index, url, dest_path)\n                for index, url, dest_path in download_tasks\n            }\n\n            # Process completed downloads with progress bar\n            with tqdm(total=len(download_tasks), desc=\"Downloading images\") as pbar:\n                for future in as_completed(futures):\n                    index, _, dest_path = futures[future]\n                    try:\n                        local_path = future.result()\n                        if local_path:\n                            gdf_copy.at[index, \"image_url\"] = local_path\n                    except Exception as e:\n                        print(f\"Error downloading image at index {index}: {str(e)}\")\n                    pbar.update(1)\n\n        return GeoImageFrame(gdf_copy, geometry=\"geometry\")\n\n    @staticmethod\n    def _create_table_row(label, value):\n        \"\"\"\n        Internal method to create an HTML table row.\n\n        Args:\n            label (str): The label for the row.\n            value (str): The value for the row.\n\n        Returns:\n            str: An HTML string representing the table row.\n        \"\"\"\n        value = value if value else \"Unknown\"\n        return f\"\"\"\n                &lt;tr&gt;\n                    &lt;td style=\"background-color: #3e95b5;\"&gt;\n                        &lt;span style=\"color: #ffffff; padding-left: 5px;\"&gt;\n                            {label}\n                        &lt;/span&gt;\n                    &lt;/td&gt;\n                    &lt;td style=\"width: 200px; padding-left: 5px; background-color: #f2f9ff;\"&gt;\n                        {value}\n                    &lt;/td&gt;\n                &lt;/tr&gt;\n                \"\"\"\n\n    def _popup_html(self, row, image_url, additional_properties):\n        \"\"\"\n        Internal method to create HTML for a popup on a map.\n\n        Args:\n            row (int): The index of the row for which to create the popup.\n            image_url (str): The URL or path of the image to display in the popup.\n            additional_properties (list): Additional properties to display in the popup.\n\n        Returns:\n            str: An HTML string representing the popup.\n        \"\"\"\n        table_rows = \"\"\n        table_rows += self._create_table_row(\"Image\", self.name[row])\n\n        for prop in additional_properties:\n            table_rows += self._create_table_row(\n                prop.capitalize(), self.get(prop, [None])[row]\n            )\n\n        if os.path.exists(image_url):\n            with open(image_url, \"rb\") as image_file:\n                encoded_image = base64.b64encode(image_file.read()).decode()\n                image_url = f\"data:image/jpg;base64,{encoded_image}\"\n\n        html = f\"\"\"\n                    &lt;!DOCTYPE html&gt;\n                    &lt;html&gt;\n                        &lt;center&gt;\n                            &lt;table style=\"width: 305px;\"&gt;\n                                &lt;tbody&gt;\n                                    {table_rows}\n                                &lt;/tbody&gt;\n                            &lt;/table&gt;\n                        &lt;/center&gt;\n                        &lt;center&gt;\n                            &lt;img src=\"{image_url}\" width=305&gt;\n                        &lt;/center&gt;\n                    &lt;/html&gt;\n                    \"\"\"\n\n        return html\n\n    def map(\n        self,\n        tiles=\"OpenStreetMap\",\n        zoom_start=18,\n        max_zoom=19,\n        additional_properties=None,\n        additional_geometries=None,\n    ):\n        \"\"\"Maps the GeoImageFrame using Folium.\n\n        Args:\n            tiles (str): Map tileset to use. Default is \"OpenStreetMap\".\n            zoom_start (int): Initial zoom level. Default is 18.\n            max_zoom (int): Maximum zoom level. Default is 19.\n            additional_properties (list, optional): Additional properties to display in the popup.\n            additional_geometries (list, optional): Additional geometries to include on the map.\n\n        Returns:\n            folium.Map: A Folium Map object displaying the GeoImageFrame.\n\n        Example:\n            m = geo_frame.map()\n            m.save('map.html')\n        \"\"\"\n        if additional_properties is None:\n            additional_properties = []\n\n        if additional_geometries is None:\n            additional_geometries = []\n\n        x = self.geometry[0].xy[0][0]\n        y = self.geometry[0].xy[1][0]\n\n        map_obj = folium.Map(\n            location=[y, x], tiles=tiles, zoom_start=zoom_start, max_zoom=max_zoom\n        )\n\n        image_urls = []\n\n        def add_markers_to_group(geo_col, angle_col, group_name):\n            nonlocal image_urls\n            marker_group = folium.FeatureGroup(name=group_name)\n\n            if geo_col not in self.columns:\n                warnings.warn(f\"Geometry field '{geo_col}' does not exist. Skipping.\")\n                return\n\n            for i, geom in self[geo_col].items():\n                if isinstance(geom, Point) and geom is not None:\n                    coordinates = [geom.xy[1][0], geom.xy[0][0]]\n\n                    url = image_urls[i] if image_urls else self.image_url[i]\n                    html = self._popup_html(i, url, additional_properties)\n                    popup = folium.Popup(html=html, max_width=500, lazy=True)\n\n                    compass_angle = getattr(self, angle_col)[i]\n                    icon = _generate_arrow_icon(compass_angle)\n\n                    marker = folium.Marker(location=coordinates, popup=popup, icon=icon)\n                    marker.add_to(marker_group)\n                else:\n                    warnings.warn(\n                        f\"Item at index {i} in '{geo_col}' is not a valid Point. Skipping.\"\n                    )\n\n            marker_group.add_to(map_obj)\n\n        add_markers_to_group(\"geometry\", \"compass_angle\", \"Images\")\n        for geom_dict in additional_geometries:\n            add_markers_to_group(\n                geom_dict[\"geometry\"], geom_dict[\"angle\"], geom_dict[\"label\"]\n            )\n\n        folium.LayerControl().add_to(map_obj)\n\n        return map_obj\n</code></pre>"},{"location":"api/geoclasses/#landlensdb.geoclasses.geoimageframe.GeoImageFrame.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the GeoImageFrame object.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Positional arguments passed to the GeoDataFrame constructor.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments passed to the GeoDataFrame constructor.</p> <code>{}</code> Source code in <code>landlensdb/geoclasses/geoimageframe.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Initialize the GeoImageFrame object.\n\n    Args:\n        *args: Positional arguments passed to the GeoDataFrame constructor.\n        **kwargs: Keyword arguments passed to the GeoDataFrame constructor.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._verify_structure()\n</code></pre>"},{"location":"api/geoclasses/#landlensdb.geoclasses.geoimageframe.GeoImageFrame._create_table_row","title":"<code>_create_table_row(label, value)</code>  <code>staticmethod</code>","text":"<p>Internal method to create an HTML table row.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label for the row.</p> required <code>value</code> <code>str</code> <p>The value for the row.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>An HTML string representing the table row.</p> Source code in <code>landlensdb/geoclasses/geoimageframe.py</code> <pre><code>@staticmethod\ndef _create_table_row(label, value):\n    \"\"\"\n    Internal method to create an HTML table row.\n\n    Args:\n        label (str): The label for the row.\n        value (str): The value for the row.\n\n    Returns:\n        str: An HTML string representing the table row.\n    \"\"\"\n    value = value if value else \"Unknown\"\n    return f\"\"\"\n            &lt;tr&gt;\n                &lt;td style=\"background-color: #3e95b5;\"&gt;\n                    &lt;span style=\"color: #ffffff; padding-left: 5px;\"&gt;\n                        {label}\n                    &lt;/span&gt;\n                &lt;/td&gt;\n                &lt;td style=\"width: 200px; padding-left: 5px; background-color: #f2f9ff;\"&gt;\n                    {value}\n                &lt;/td&gt;\n            &lt;/tr&gt;\n            \"\"\"\n</code></pre>"},{"location":"api/geoclasses/#landlensdb.geoclasses.geoimageframe.GeoImageFrame._download_image_from_url","title":"<code>_download_image_from_url(url, dest_path, max_retries=3, retry_delay=1)</code>  <code>staticmethod</code>","text":"<p>Internal method to download an image from a URL with retries.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the image to download.</p> required <code>dest_path</code> <code>str</code> <p>The destination path to save the downloaded image.</p> required <code>max_retries</code> <code>int</code> <p>Maximum number of retry attempts.</p> <code>3</code> <code>retry_delay</code> <code>int</code> <p>Delay between retries in seconds.</p> <code>1</code> <p>Returns:</p> Type Description <code>str | None</code> <p>The local path where the image was downloaded, or None if failed.</p> Source code in <code>landlensdb/geoclasses/geoimageframe.py</code> <pre><code>@staticmethod\ndef _download_image_from_url(\n    url: str,\n    dest_path: str,\n    max_retries: int = 3,\n    retry_delay: int = 1\n) -&gt; str | None:\n    \"\"\"Internal method to download an image from a URL with retries.\n\n    Args:\n        url: The URL of the image to download.\n        dest_path: The destination path to save the downloaded image.\n        max_retries: Maximum number of retry attempts.\n        retry_delay: Delay between retries in seconds.\n\n    Returns:\n        The local path where the image was downloaded, or None if failed.\n    \"\"\"\n    from time import sleep\n\n    for attempt in range(max_retries):\n        try:\n            response = requests.get(url, stream=True)\n            response.raise_for_status()\n\n            with open(dest_path, \"wb\") as f:\n                for chunk in response.iter_content(chunk_size=8192):\n                    if chunk:  # Filter out keep-alive chunks\n                        f.write(chunk)\n\n            return dest_path\n\n        except requests.RequestException as e:\n            if attempt &lt; max_retries - 1:\n                msg = (\n                    f\"Attempt {attempt + 1} failed downloading {url}. \"\n                    f\"Error: {e}. Retrying...\"\n                )\n                print(msg)\n                sleep(retry_delay)\n            else:\n                msg = (\n                    f\"Failed to download {url} after {max_retries} \"\n                    f\"attempts. Error: {e}\"\n                )\n                print(msg)\n\n    return None\n</code></pre>"},{"location":"api/geoclasses/#landlensdb.geoclasses.geoimageframe.GeoImageFrame._popup_html","title":"<code>_popup_html(row, image_url, additional_properties)</code>","text":"<p>Internal method to create HTML for a popup on a map.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>int</code> <p>The index of the row for which to create the popup.</p> required <code>image_url</code> <code>str</code> <p>The URL or path of the image to display in the popup.</p> required <code>additional_properties</code> <code>list</code> <p>Additional properties to display in the popup.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>An HTML string representing the popup.</p> Source code in <code>landlensdb/geoclasses/geoimageframe.py</code> <pre><code>def _popup_html(self, row, image_url, additional_properties):\n    \"\"\"\n    Internal method to create HTML for a popup on a map.\n\n    Args:\n        row (int): The index of the row for which to create the popup.\n        image_url (str): The URL or path of the image to display in the popup.\n        additional_properties (list): Additional properties to display in the popup.\n\n    Returns:\n        str: An HTML string representing the popup.\n    \"\"\"\n    table_rows = \"\"\n    table_rows += self._create_table_row(\"Image\", self.name[row])\n\n    for prop in additional_properties:\n        table_rows += self._create_table_row(\n            prop.capitalize(), self.get(prop, [None])[row]\n        )\n\n    if os.path.exists(image_url):\n        with open(image_url, \"rb\") as image_file:\n            encoded_image = base64.b64encode(image_file.read()).decode()\n            image_url = f\"data:image/jpg;base64,{encoded_image}\"\n\n    html = f\"\"\"\n                &lt;!DOCTYPE html&gt;\n                &lt;html&gt;\n                    &lt;center&gt;\n                        &lt;table style=\"width: 305px;\"&gt;\n                            &lt;tbody&gt;\n                                {table_rows}\n                            &lt;/tbody&gt;\n                        &lt;/table&gt;\n                    &lt;/center&gt;\n                    &lt;center&gt;\n                        &lt;img src=\"{image_url}\" width=305&gt;\n                    &lt;/center&gt;\n                &lt;/html&gt;\n                \"\"\"\n\n    return html\n</code></pre>"},{"location":"api/geoclasses/#landlensdb.geoclasses.geoimageframe.GeoImageFrame._verify_structure","title":"<code>_verify_structure()</code>","text":"<p>Verifies the structure of the GeoImageFrame to ensure it has the required columns and datatypes.</p> Source code in <code>landlensdb/geoclasses/geoimageframe.py</code> <pre><code>def _verify_structure(self):\n    \"\"\"Verifies the structure of the GeoImageFrame to ensure it has the required columns and datatypes.\"\"\"\n    required_columns = {\"image_url\": str, \"name\": str, \"geometry\": Point}\n\n    for col, dtype in required_columns.items():\n        if col not in self.columns:\n            raise ValueError(f\"The required column '{col}' is missing.\")\n\n        # Check if the elements are of the correct type\n        wrong_type_mask = ~self[col].apply(lambda x: isinstance(x, dtype))\n        if wrong_type_mask.any():\n            raise TypeError(f\"Column '{col}' contains wrong data type.\")\n</code></pre>"},{"location":"api/geoclasses/#landlensdb.geoclasses.geoimageframe.GeoImageFrame.download_images_to_local","title":"<code>download_images_to_local(dest_dir, filename_column=None, max_workers=10)</code>","text":"<p>Downloads the images specified in the 'image_url' column of the GeoDataFrame to a local directory using multiple threads.</p> <p>Parameters:</p> Name Type Description Default <code>dest_dir</code> <code>str</code> <p>The destination directory where the images will be downloaded.</p> required <code>filename_column</code> <code>str</code> <p>Column to use for the filename. Defaults to the filename in the URL.</p> <code>None</code> <code>max_workers</code> <code>int</code> <p>Maximum number of concurrent download threads. Defaults to 10.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>GeoImageFrame</code> <p>A new GeoImageFrame with the local paths to the downloaded images.</p> Example <p>local_gdf = geo_image_frame.download_images_to_local('images/', max_workers=20)</p> Source code in <code>landlensdb/geoclasses/geoimageframe.py</code> <pre><code>def download_images_to_local(self, dest_dir, filename_column=None, max_workers=10):\n    \"\"\"\n    Downloads the images specified in the 'image_url' column of the GeoDataFrame to a local directory using multiple threads.\n\n    Args:\n        dest_dir (str): The destination directory where the images will be downloaded.\n        filename_column (str, optional): Column to use for the filename. Defaults to the filename in the URL.\n        max_workers (int, optional): Maximum number of concurrent download threads. Defaults to 10.\n\n    Returns:\n        GeoImageFrame: A new GeoImageFrame with the local paths to the downloaded images.\n\n    Example:\n        local_gdf = geo_image_frame.download_images_to_local('images/', max_workers=20)\n    \"\"\"\n    import os\n    from concurrent.futures import ThreadPoolExecutor, as_completed\n\n    if \"image_url\" not in self.columns:\n        raise ValueError(\"The GeoImageFrame must have a column named 'image_url'.\")\n\n    # Create destination directory if it doesn't exist\n    os.makedirs(dest_dir, exist_ok=True)\n\n    gdf_copy = self.copy()\n    download_tasks = []\n\n    # Prepare download tasks\n    for index, row in gdf_copy.iterrows():\n        image_url = row[\"image_url\"]\n\n        # Skip placeholder URLs\n        if image_url.startswith(\"placeholder://\"):\n            print(f\"Skipping placeholder URL: {image_url}\")\n            continue\n\n        # Skip non-HTTP URLs\n        if not image_url.startswith((\"http://\", \"https://\")):\n            print(f\"Skipping {image_url}. It's not a valid URL.\")\n            continue\n\n        original_filename = image_url.split(\"/\")[-1].split(\".\")[0]\n        filename_value = row.get(filename_column, original_filename)\n        destination_path = os.path.join(dest_dir, f\"{filename_value}.jpg\")\n\n        download_tasks.append((index, image_url, destination_path))\n\n    # Download images using thread pool\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = {\n            executor.submit(self._download_image_from_url, url, dest_path): (index, url, dest_path)\n            for index, url, dest_path in download_tasks\n        }\n\n        # Process completed downloads with progress bar\n        with tqdm(total=len(download_tasks), desc=\"Downloading images\") as pbar:\n            for future in as_completed(futures):\n                index, _, dest_path = futures[future]\n                try:\n                    local_path = future.result()\n                    if local_path:\n                        gdf_copy.at[index, \"image_url\"] = local_path\n                except Exception as e:\n                    print(f\"Error downloading image at index {index}: {str(e)}\")\n                pbar.update(1)\n\n    return GeoImageFrame(gdf_copy, geometry=\"geometry\")\n</code></pre>"},{"location":"api/geoclasses/#landlensdb.geoclasses.geoimageframe.GeoImageFrame.map","title":"<code>map(tiles='OpenStreetMap', zoom_start=18, max_zoom=19, additional_properties=None, additional_geometries=None)</code>","text":"<p>Maps the GeoImageFrame using Folium.</p> <p>Parameters:</p> Name Type Description Default <code>tiles</code> <code>str</code> <p>Map tileset to use. Default is \"OpenStreetMap\".</p> <code>'OpenStreetMap'</code> <code>zoom_start</code> <code>int</code> <p>Initial zoom level. Default is 18.</p> <code>18</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level. Default is 19.</p> <code>19</code> <code>additional_properties</code> <code>list</code> <p>Additional properties to display in the popup.</p> <code>None</code> <code>additional_geometries</code> <code>list</code> <p>Additional geometries to include on the map.</p> <code>None</code> <p>Returns:</p> Type Description <p>folium.Map: A Folium Map object displaying the GeoImageFrame.</p> Example <p>m = geo_frame.map() m.save('map.html')</p> Source code in <code>landlensdb/geoclasses/geoimageframe.py</code> <pre><code>def map(\n    self,\n    tiles=\"OpenStreetMap\",\n    zoom_start=18,\n    max_zoom=19,\n    additional_properties=None,\n    additional_geometries=None,\n):\n    \"\"\"Maps the GeoImageFrame using Folium.\n\n    Args:\n        tiles (str): Map tileset to use. Default is \"OpenStreetMap\".\n        zoom_start (int): Initial zoom level. Default is 18.\n        max_zoom (int): Maximum zoom level. Default is 19.\n        additional_properties (list, optional): Additional properties to display in the popup.\n        additional_geometries (list, optional): Additional geometries to include on the map.\n\n    Returns:\n        folium.Map: A Folium Map object displaying the GeoImageFrame.\n\n    Example:\n        m = geo_frame.map()\n        m.save('map.html')\n    \"\"\"\n    if additional_properties is None:\n        additional_properties = []\n\n    if additional_geometries is None:\n        additional_geometries = []\n\n    x = self.geometry[0].xy[0][0]\n    y = self.geometry[0].xy[1][0]\n\n    map_obj = folium.Map(\n        location=[y, x], tiles=tiles, zoom_start=zoom_start, max_zoom=max_zoom\n    )\n\n    image_urls = []\n\n    def add_markers_to_group(geo_col, angle_col, group_name):\n        nonlocal image_urls\n        marker_group = folium.FeatureGroup(name=group_name)\n\n        if geo_col not in self.columns:\n            warnings.warn(f\"Geometry field '{geo_col}' does not exist. Skipping.\")\n            return\n\n        for i, geom in self[geo_col].items():\n            if isinstance(geom, Point) and geom is not None:\n                coordinates = [geom.xy[1][0], geom.xy[0][0]]\n\n                url = image_urls[i] if image_urls else self.image_url[i]\n                html = self._popup_html(i, url, additional_properties)\n                popup = folium.Popup(html=html, max_width=500, lazy=True)\n\n                compass_angle = getattr(self, angle_col)[i]\n                icon = _generate_arrow_icon(compass_angle)\n\n                marker = folium.Marker(location=coordinates, popup=popup, icon=icon)\n                marker.add_to(marker_group)\n            else:\n                warnings.warn(\n                    f\"Item at index {i} in '{geo_col}' is not a valid Point. Skipping.\"\n                )\n\n        marker_group.add_to(map_obj)\n\n    add_markers_to_group(\"geometry\", \"compass_angle\", \"Images\")\n    for geom_dict in additional_geometries:\n        add_markers_to_group(\n            geom_dict[\"geometry\"], geom_dict[\"angle\"], geom_dict[\"label\"]\n        )\n\n    folium.LayerControl().add_to(map_obj)\n\n    return map_obj\n</code></pre>"},{"location":"api/geoclasses/#landlensdb.geoclasses.geoimageframe.GeoImageFrame.to_dict_records","title":"<code>to_dict_records()</code>","text":"<p>Converts the GeoImageFrame to a dictionary representation.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of dictionaries representing the GeoImageFrame rows.</p> Source code in <code>landlensdb/geoclasses/geoimageframe.py</code> <pre><code>def to_dict_records(self):\n    \"\"\"Converts the GeoImageFrame to a dictionary representation.\n\n    Returns:\n        list: List of dictionaries representing the GeoImageFrame rows.\n    \"\"\"\n    return self.to_dict(\"records\")\n</code></pre>"},{"location":"api/geoclasses/#landlensdb.geoclasses.geoimageframe.GeoImageFrame.to_file","title":"<code>to_file(filename, **kwargs)</code>","text":"<p>Saves the GeoImageFrame to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename or path to save the GeoImageFrame.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the 'to_file' method.</p> <code>{}</code> Source code in <code>landlensdb/geoclasses/geoimageframe.py</code> <pre><code>def to_file(self, filename, **kwargs):\n    \"\"\"Saves the GeoImageFrame to a file.\n\n    Args:\n        filename (str): The filename or path to save the GeoImageFrame.\n        **kwargs: Additional keyword arguments for the 'to_file' method.\n    \"\"\"\n    for col in self.columns:\n        if col != \"geometry\":\n            self[col] = self[col].apply(\n                lambda x: x.wkt if isinstance(x, Point) else x\n            )\n\n    super().to_file(filename, **kwargs)\n</code></pre>"},{"location":"api/geoclasses/#landlensdb.geoclasses.geoimageframe.GeoImageFrame.to_postgis","title":"<code>to_postgis(name, engine, if_exists='fail', *args, **kwargs)</code>","text":"<p>Saves the GeoImageFrame to a PostGIS database.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the table to create or update.</p> required <code>engine</code> <code>Engine</code> <p>SQLAlchemy engine connected to the database.</p> required <code>if_exists</code> <code>str</code> <p>Behavior if the table already exists in the database. Default is \"fail\".</p> <code>'fail'</code> <code>*args</code> <p>Additional positional arguments for the 'to_postgis' method.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments for the 'to_postgis' method.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required columns are missing or if the CRS is incorrect.</p> <code>TypeError</code> <p>If the columns contain incorrect data types.</p> Source code in <code>landlensdb/geoclasses/geoimageframe.py</code> <pre><code>def to_postgis(self, name, engine, if_exists=\"fail\", *args, **kwargs):\n    \"\"\"Saves the GeoImageFrame to a PostGIS database.\n\n    Args:\n        name (str): Name of the table to create or update.\n        engine (sqlalchemy.engine.Engine): SQLAlchemy engine connected to the database.\n        if_exists (str): Behavior if the table already exists in the database. Default is \"fail\".\n        *args: Additional positional arguments for the 'to_postgis' method.\n        **kwargs: Additional keyword arguments for the 'to_postgis' method.\n\n    Raises:\n        ValueError: If required columns are missing or if the CRS is incorrect.\n        TypeError: If the columns contain incorrect data types.\n    \"\"\"\n    required_columns = [\"name\", \"image_url\", \"geometry\"]\n    for col in required_columns:\n        if col not in self.columns:\n            raise ValueError(f\"Column '{col}' is missing.\")\n\n    if not self[\"name\"].apply(isinstance, args=(str,)).all():\n        raise TypeError(\"All entries in 'name' column must be of type string.\")\n\n    if not self[\"image_url\"].apply(isinstance, args=(str,)).all():\n        raise TypeError(\"All entries in 'image_url' column must be of type string.\")\n\n    if self[\"image_url\"].duplicated().any():\n        raise ValueError(\n            \"'image_url' column has duplicate entries. It must be unique.\"\n        )\n\n    if not all(geom.geom_type == \"Point\" for geom in self[\"geometry\"]):\n        raise TypeError(\"All geometries must be of type Point.\")\n\n    if self.crs != \"EPSG:4326\":\n        raise ValueError(\"CRS must be EPSG:4326.\")\n\n    metadata = MetaData()\n    metadata.reflect(bind=engine)\n\n    if not inspect(engine).has_table(name):\n        super().to_postgis(name, engine, if_exists=if_exists, *args, **kwargs)\n    else:\n        if if_exists == \"fail\":\n            raise ValueError(f\"Table '{name}' already exists.\")\n        elif if_exists == \"replace\":\n            table = metadata.tables[name]\n            with engine.connect() as conn:\n                table.drop(conn)\n            super().to_postgis(name, engine, if_exists=\"replace\", *args, **kwargs)\n\n        elif if_exists == \"append\":\n            super().to_postgis(name, engine, if_exists=\"append\", *args, **kwargs)\n\n    metadata.reflect(bind=engine)\n    table = metadata.tables[name]\n\n    with engine.connect() as conn:\n        for col in required_columns:\n            stmt = text(f\"ALTER TABLE {table.name} ALTER COLUMN {col} SET NOT NULL\")\n            conn.execute(stmt)\n\n        constraint_name = f\"{table.name}_image_url_key\"\n\n        stmt = text(\n            f\"ALTER TABLE {table.name} \"\n            f\"ADD CONSTRAINT {constraint_name} UNIQUE (image_url)\"\n        )\n        conn.execute(stmt)\n        conn.connection.commit()\n</code></pre>"},{"location":"api/geoclasses/#landlensdb.geoclasses.geoimageframe._generate_arrow_icon","title":"<code>_generate_arrow_icon(compass_angle)</code>","text":"<p>Generates an arrow icon based on the specified compass angle.</p> <p>Parameters:</p> Name Type Description Default <code>compass_angle</code> <code>float</code> <p>The compass angle in degrees to which the arrow points.</p> required <p>Returns:</p> Type Description <p>folium.features.CustomIcon: A Folium CustomIcon object representing the arrow.</p> Example <p>icon = generate_arrow_icon(90) marker = folium.Marker(location=[lat, lon], icon=icon)</p> Source code in <code>landlensdb/geoclasses/geoimageframe.py</code> <pre><code>def _generate_arrow_icon(compass_angle):\n    \"\"\"Generates an arrow icon based on the specified compass angle.\n\n    Args:\n        compass_angle (float): The compass angle in degrees to which the arrow points.\n\n    Returns:\n        folium.features.CustomIcon: A Folium CustomIcon object representing the arrow.\n\n    Example:\n        icon = generate_arrow_icon(90)\n        marker = folium.Marker(location=[lat, lon], icon=icon)\n    \"\"\"\n    svg = _generate_arrow_svg(compass_angle)\n    encoded = base64.b64encode(svg.encode(\"utf-8\")).decode(\"utf-8\")\n    data_url = f\"data:image/svg+xml;base64,{encoded}\"\n\n    icon = CustomIcon(icon_image=data_url, icon_size=(45, 45))\n    return icon\n</code></pre>"},{"location":"api/geoclasses/#landlensdb.geoclasses.geoimageframe._generate_arrow_svg","title":"<code>_generate_arrow_svg(compass_angle)</code>","text":"<p>Generates an SVG string representing an arrow pointing to the specified compass angle.</p> <p>Parameters:</p> Name Type Description Default <code>compass_angle</code> <code>float</code> <p>The compass angle in degrees to which the arrow points.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The SVG string of the arrow.</p> Example <p>svg_str = generate_arrow_svg(45)</p> Source code in <code>landlensdb/geoclasses/geoimageframe.py</code> <pre><code>def _generate_arrow_svg(compass_angle):\n    \"\"\"Generates an SVG string representing an arrow pointing to the specified compass angle.\n\n    Args:\n        compass_angle (float): The compass angle in degrees to which the arrow points.\n\n    Returns:\n        str: The SVG string of the arrow.\n\n    Example:\n        svg_str = generate_arrow_svg(45)\n    \"\"\"\n    return f\"\"\"\n&lt;svg width=\"200\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\"&gt;\n    &lt;!-- Background circle (lighter blue dot) --&gt;\n    &lt;circle cx=\"100\" cy=\"100\" r=\"40\" fill=\"#6699FF\"/&gt;\n\n    &lt;g transform=\"rotate({compass_angle}, 100, 100)\"&gt;\n        &lt;!-- Field of view arc. This example shows a FOV centered on the top (north) and spans 45 degrees --&gt;\n        &lt;path d=\"M100,100 L150,50 A70,70 0 0,0 50,50 Z\" fill=\"rgba(0,0,255,0.3)\"/&gt;\n    &lt;/g&gt;\n\n    &lt;!-- Camera icon, adjusted to center --&gt;\n    &lt;rect x=\"80\" y=\"86.5\" width=\"40\" height=\"27\" fill=\"white\"/&gt;\n    &lt;circle cx=\"100\" cy=\"99.5\" r=\"9\" fill=\"#6699FF\" stroke=\"white\" stroke-width=\"2.5\"/&gt;\n    &lt;rect x=\"90\" y=\"79.5\" width=\"20\" height=\"7\" fill=\"white\"/&gt;\n&lt;/svg&gt;\n    \"\"\"\n</code></pre>"},{"location":"api/handlers/","title":"Handlers API","text":""},{"location":"api/handlers/#cloud-handler","title":"Cloud Handler","text":""},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary","title":"<code>Mapillary</code>","text":"<p>Class to interact with Mapillary's API to fetch image data.</p> <p>Parameters:</p> Name Type Description Default <code>mapillary_token</code> <code>str</code> <p>The authentication token for Mapillary.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; mapillary = Mapillary(\"YOUR_TOKEN_HERE\")\n&gt;&gt;&gt; images = mapillary.fetch_within_bbox([12.34, 56.78, 90.12, 34.56])\n</code></pre> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>class Mapillary:\n    \"\"\"\n    Class to interact with Mapillary's API to fetch image data.\n\n    Args:\n        mapillary_token (str): The authentication token for Mapillary.\n\n    Examples:\n        &gt;&gt;&gt; mapillary = Mapillary(\"YOUR_TOKEN_HERE\")\n        &gt;&gt;&gt; images = mapillary.fetch_within_bbox([12.34, 56.78, 90.12, 34.56])\n    \"\"\"\n\n    BASE_URL = \"https://graph.mapillary.com\"\n    TILES_URL = \"https://tiles.mapillary.com\"\n    REQUIRED_FIELDS = [\"id\", \"geometry\"]\n    FIELDS_LIST = [\n        \"id\",\n        \"altitude\",\n        \"atomic_scale\",\n        \"camera_parameters\",\n        \"camera_type\",\n        \"captured_at\",\n        \"compass_angle\",\n        \"computed_altitude\",\n        \"computed_compass_angle\",\n        \"computed_geometry\",\n        \"computed_rotation\",\n        \"exif_orientation\",\n        \"geometry\",\n        \"height\",\n        \"thumb_1024_url\",\n        \"merge_cc\",\n        \"mesh\",\n        \"sequence\",\n        \"sfm_cluster\",\n        \"width\",\n        \"detections\",\n        \"quality_score\"  # Added quality score field\n    ]\n\n    QUALITY_INDICATORS = [\n        \"quality_score\",  # Primary quality indicator\n        \"computed_compass_angle\",  # Secondary indicator\n        \"atomic_scale\"  # Tertiary indicator\n    ]\n    IMAGE_URL_KEYS = [\n        \"thumb_256_url\",\n        \"thumb_1024_url\",\n        \"thumb_2048_url\",\n        \"thumb_original_url\",\n    ]\n    LIMIT = 2000\n    TF = TimezoneFinder()\n    ZOOM_LEVEL = 14  # Default zoom level for coverage tiles\n\n    def __init__(self, mapillary_token):\n        \"\"\"\n        Initialize a Mapillary object.\n\n        Args:\n            mapillary_token (str): The authentication token for Mapillary.\n        \"\"\"\n        self.TOKEN = mapillary_token\n\n    def _validate_fields(self, fields):\n        \"\"\"\n        Validates the fields for fetching data.\n\n        Args:\n            fields (list): The fields to be validated.\n\n        Raises:\n            ValueError: If the required fields are missing.\n        \"\"\"\n        if (\n            \"id\" not in fields\n            or \"geometry\" not in fields\n            or not any(image_field in fields for image_field in self.IMAGE_URL_KEYS)\n        ):\n            raise ValueError(\n                \"Fields must contain 'id', 'geometry', and one of \"\n                + str(self.IMAGE_URL_KEYS)\n            )\n\n    @staticmethod\n    def _split_bbox(inner_bbox):\n        \"\"\"\n        Splits a bounding box into four quarters.\n\n        Args:\n            inner_bbox (list): A list representing the bounding box to split.\n\n        Returns:\n            list: A list of four bounding boxes, each representing a quarter.\n        \"\"\"\n        x1, y1, x2, y2 = inner_bbox[:]\n        xm = (x2 - x1) / 2\n        ym = (y2 - y1) / 2\n\n        q1 = [x1, y1, x1 + xm, y1 + ym]\n        q2 = [x1 + xm, y1, x2, y1 + ym]\n        q3 = [x1, y1 + ym, x1 + xm, y2]\n        q4 = [x1 + xm, y1 + ym, x2, y2]\n\n        return [q1, q2, q3, q4]\n\n    def _json_to_gdf(self, json_data):\n        \"\"\"\n        Converts JSON data from Mapillary to a GeoDataFrame.\n\n        Args:\n            json_data (list): A list of JSON data from Mapillary.\n\n        Returns:\n            GeoDataFrame: A GeoDataFrame containing the image data.\n        \"\"\"\n        # Early return if no data\n        if not json_data:\n            return GeoDataFrame(geometry=[])\n\n        for img in json_data:\n            # Basic field conversions\n            coords = img.get(\"geometry\", {}).get(\"coordinates\", [None, None])\n            img[\"geometry\"] = Point(coords)\n            img[\"mly_id\"] = img.pop(\"id\")\n            img[\"name\"] = f\"mly|{img['mly_id']}\"\n\n            # Handle computed geometry\n            if \"computed_geometry\" in img:\n                coords = img.get(\"computed_geometry\", {}).get(\n                    \"coordinates\", [None, None]\n                )\n                img[\"computed_geometry\"] = Point(coords)\n\n            # Process timestamp with timezone\n            if \"captured_at\" in img:\n                lat = img[\"geometry\"].y\n                lng = img[\"geometry\"].x\n                img[\"captured_at\"] = self._process_timestamp(\n                    img.get(\"captured_at\"), lat, lng\n                )\n\n            # Set image URL from available options\n            image_url_found = False\n            for key in self.IMAGE_URL_KEYS:\n                if key in img:\n                    img[\"image_url\"] = str(img.pop(key))  # Explicitly convert to string\n                    image_url_found = True\n                    break\n\n            # If no image URL was found, set a placeholder URL\n            # Instead of using a direct Mapillary API URL that might fail,\n            # we'll use a placeholder that indicates the image URL is missing\n            if not image_url_found:\n                img[\"image_url\"] = f\"placeholder://mapillary/{img['mly_id']}\"\n\n            # Convert list parameters to strings\n            for key in [\"camera_parameters\", \"computed_rotation\"]:\n                if key in img and isinstance(img[key], list):\n                    img[key] = \",\".join(map(str, img[key]))\n\n            # Calculate quality score if not present\n            if \"quality_score\" not in img:\n                quality_score = 0.0\n                if \"computed_compass_angle\" in img:\n                    quality_score += 0.5  # Good compass data\n                if \"atomic_scale\" in img:\n                    quality_score += 0.3  # Good scale data\n                if img.get(\"camera_type\"):\n                    quality_score += 0.2  # Camera type available\n                img[\"quality_score\"] = quality_score\n\n        # Create GeoDataFrame\n        gdf = GeoDataFrame(json_data, crs=\"EPSG:4326\")\n        gdf.set_geometry(\"geometry\", inplace=True)\n\n        # Sort by quality indicators and drop duplicates by sequence\n        if \"sequence\" in gdf.columns:\n            sort_columns = [col for col in self.QUALITY_INDICATORS if col in gdf.columns]\n            if sort_columns:\n                gdf = gdf.sort_values(sort_columns, ascending=False)\n                gdf = gdf.drop_duplicates(subset=['sequence'], keep='first')\n\n        # Ensure image_url is a string type\n        if \"image_url\" in gdf.columns:\n            gdf[\"image_url\"] = gdf[\"image_url\"].astype(str)\n\n        return gdf\n\n    def _bbox_to_tile_coords(self, bbox, zoom):\n        \"\"\"\n        Convert a bounding box to tile coordinates at a given zoom level.\n\n        Args:\n            bbox (list): [west, south, east, north] coordinates\n            zoom (int): Zoom level\n\n        Returns:\n            tuple: (min_x, min_y, max_x, max_y) tile coordinates\n        \"\"\"\n        def lat_to_tile_y(lat_deg, zoom):\n            lat_rad = math.radians(lat_deg)\n            n = 2.0 ** zoom\n            return int((1.0 - math.asinh(math.tan(lat_rad)) / math.pi) / 2.0 * n)\n\n        def lon_to_tile_x(lon_deg, zoom):\n            n = 2.0 ** zoom\n            return int((lon_deg + 180.0) / 360.0 * n)\n\n        west, south, east, north = bbox\n        min_x = lon_to_tile_x(west, zoom)\n        max_x = lon_to_tile_x(east, zoom)\n        min_y = lat_to_tile_y(north, zoom)  # Note: y coordinates are inverted\n        max_y = lat_to_tile_y(south, zoom)\n\n        return min_x, min_y, max_x, max_y\n\n    def _tile_to_bbox(self, tile, zoom_level):\n        \"\"\"\n        Converts tile coordinates to a bounding box.\n\n        Args:\n            tile (dict): Tile coordinates (x, y).\n            zoom_level (int): The zoom level of the tile.\n\n        Returns:\n            list: Bounding box coordinates [west, south, east, north].\n        \"\"\"\n        x, y = tile['x'], tile['y']\n        n = 2.0 ** zoom_level\n        west = x / n * 360.0 - 180.0\n        east = (x + 1) / n * 360.0 - 180.0\n\n        def inv_lat(y_tile):\n            return math.degrees(math.atan(math.sinh(math.pi * (1 - 2 * y_tile / n))))\n\n        north = inv_lat(y)\n        south = inv_lat(y + 1)\n\n        return [west, south, east, north]\n\n    def _fetch_coverage_tile(self, zoom, x, y):\n        \"\"\"\n        Fetches a single coverage tile.\n\n        Args:\n            zoom (int): Zoom level\n            x (int): Tile X coordinate\n            y (int): Tile Y coordinate\n\n        Returns:\n            list: Image features from the tile\n        \"\"\"\n        url = (\n            f\"{self.TILES_URL}/maps/vtp/mly1_public/2\"\n            f\"/{zoom}/{x}/{y}\"\n            f\"?access_token={self.TOKEN}\"\n        )\n\n        try:\n            response = requests.get(url)\n            if response.status_code == 200:\n                # Vector tiles are binary, not JSON\n                if 'application/x-protobuf' in response.headers.get('content-type', ''):\n                    try:\n                        # Decode the vector tile\n                        tile_data = mapbox_vector_tile.decode(response.content)\n\n                        # Check for image layer at zoom level 14\n                        if 'image' in tile_data and zoom == 14:\n                            return tile_data['image']['features']\n\n                        # Check for sequence layer at zoom levels 6-14\n                        elif 'sequence' in tile_data and 6 &lt;= zoom &lt;= 14:\n                            return tile_data['sequence']['features']\n\n                        # Check for overview layer at zoom levels 0-5\n                        elif 'overview' in tile_data and 0 &lt;= zoom &lt;= 5:\n                            return tile_data['overview']['features']\n\n                        else:\n                            warnings.warn(f\"No usable layers found in tile {x},{y}\")\n                            return []\n\n                    except Exception as e:\n                        warnings.warn(f\"Error decoding vector tile {x},{y}: {str(e)}\")\n                        return []\n                else:\n                    warnings.warn(f\"Unexpected content type for tile {x},{y}\")\n                    return []\n            else:\n                warnings.warn(f\"Error fetching tile {x},{y}: {response.status_code}\")\n                return []\n        except Exception as e:\n            warnings.warn(f\"Exception fetching tile {x},{y}: {str(e)}\")\n            return []\n\n    def _extract_image_ids_from_features(self, features):\n        \"\"\"\n        Extracts image IDs from tile features.\n\n        Args:\n            features (list): List of features from a vector tile\n\n        Returns:\n            list: List of image IDs\n        \"\"\"\n        image_ids = []\n\n        for feature in features:\n            if 'id' in feature.get('properties', {}):\n                image_ids.append(str(feature['properties']['id']))\n            elif 'image_id' in feature.get('properties', {}):\n                image_ids.append(str(feature['properties']['image_id']))\n\n        return image_ids\n\n    def _fetch_image_metadata(self, image_ids, fields, max_workers=10):\n        \"\"\"\n        Fetches metadata for multiple images using multi-threading.\n\n        Args:\n            image_ids (list): List of image IDs\n            fields (list): Fields to include in the response\n            max_workers (int, optional): Maximum number of concurrent workers. Default is 10.\n\n        Returns:\n            list: List of image metadata\n        \"\"\"\n        results = []\n\n        def fetch_single_image(image_id):\n            url = (\n                f\"{self.BASE_URL}/{image_id}\"\n                f\"?access_token={self.TOKEN}\"\n                f\"&amp;fields={','.join(fields)}\"\n            )\n\n            try:\n                response = requests.get(url)\n                if response.status_code == 200:\n                    return response.json()\n                else:\n                    warnings.warn(f\"Error fetching image {image_id}: {response.status_code}\")\n                    return None\n            except Exception as e:\n                warnings.warn(f\"Exception fetching image {image_id}: {str(e)}\")\n                return None\n\n        # Use ThreadPoolExecutor for parallel fetching\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # Submit all tasks and create a map of future to image_id\n            future_to_id = {executor.submit(fetch_single_image, image_id): image_id\n                           for image_id in image_ids}\n\n            # Process results as they complete with a progress bar\n            for future in tqdm(as_completed(future_to_id),\n                              total=len(image_ids),\n                              desc=\"Fetching metadata\"):\n                result = future.result()\n                if result:\n                    results.append(result)\n\n        return results\n\n    def fetch_within_bbox(\n        self,\n        initial_bbox,\n        start_date=None,\n        end_date=None,\n        fields=None,\n        max_recursion_depth=25,\n        use_coverage_tiles=True,\n        max_images=5000,\n        max_workers=10\n    ):\n        \"\"\"\n        Fetches images within a bounding box.\n\n        Args:\n            initial_bbox (list): The bounding box to fetch images from [west, south, east, north].\n            start_date (str, optional): Start date for filtering images (YYYY-MM-DD).\n            end_date (str, optional): End date for filtering images (YYYY-MM-DD).\n            fields (list, optional): Fields to include in the response.\n            max_recursion_depth (int, optional): Maximum depth for recursive fetching.\n            use_coverage_tiles (bool, optional): Whether to use coverage tiles API for large areas.\n            max_images (int, optional): Maximum number of images to process. Default is 5000.\n            max_workers (int, optional): Maximum number of concurrent workers. Default is 10.\n\n        Returns:\n            GeoImageFrame: A GeoImageFrame containing the image data.\n        \"\"\"\n        if fields is None:\n            fields = self.FIELDS_LIST\n\n        # Ensure required fields are included\n        if \"id\" not in fields:\n            fields.append(\"id\")\n        if \"geometry\" not in fields:\n            fields.append(\"geometry\")\n        if not any(url_key in fields for url_key in self.IMAGE_URL_KEYS):\n            fields.append(\"thumb_1024_url\")\n\n        start_timestamp = self._get_timestamp(start_date) if start_date else None\n        end_timestamp = self._get_timestamp(end_date, True) if end_date else None\n\n        if use_coverage_tiles:\n            # Get coverage tiles for the area\n            min_x, min_y, max_x, max_y = self._bbox_to_tile_coords(initial_bbox, self.ZOOM_LEVEL)\n\n            all_image_ids = []\n            print(f\"Fetching {(max_x - min_x + 1) * (max_y - min_y + 1)} tiles...\")\n\n            # Fetch all tiles in the bounding box\n            for x in range(min_x, max_x + 1):\n                for y in range(min_y, max_y + 1):\n                    features = self._fetch_coverage_tile(self.ZOOM_LEVEL, x, y)\n                    image_ids = self._extract_image_ids_from_features(features)\n                    all_image_ids.extend(image_ids)\n\n                    # Check if we've reached the maximum number of images\n                    if len(all_image_ids) &gt;= max_images * 2:  # Get more than needed to allow for filtering\n                        print(f\"Reached maximum number of images ({max_images}), stopping tile fetching\")\n                        break\n\n                # Check again after processing a row of tiles\n                if len(all_image_ids) &gt;= max_images * 2:\n                    break\n\n            print(f\"Found {len(all_image_ids)} total images\")\n\n            # Remove duplicates\n            all_image_ids = list(set(all_image_ids))\n            print(f\"After removing duplicates: {len(all_image_ids)} unique images\")\n\n            # Limit the number of images to process\n            if len(all_image_ids) &gt; max_images:\n                print(f\"Limiting to {max_images} images for processing\")\n                all_image_ids = all_image_ids[:max_images]\n\n            # Fetch metadata for all images using multi-threading\n            all_data = self._fetch_image_metadata(all_image_ids, fields, max_workers=max_workers)\n\n            data = self._json_to_gdf(all_data)\n            return GeoImageFrame(data, geometry=\"geometry\")\n        else:\n            # Use traditional recursive fetching\n            data = self._recursive_fetch(\n                initial_bbox,\n                fields,\n                start_timestamp,\n                end_timestamp,\n                max_recursion_depth=max_recursion_depth\n            )\n            gdf = self._json_to_gdf(data)\n            return GeoImageFrame(gdf, geometry=\"geometry\")\n\n    def fetch_by_id(self, image_id, fields=None):\n        \"\"\"\n        Fetches an image by its ID.\n\n        Args:\n            image_id (str): The ID of the image to fetch.\n            fields (list, optional): The fields to include in the response.\n\n        Returns:\n            GeoImageFrame: A GeoImageFrame containing the fetched image.\n\n        Raises:\n            Exception: If the connection to Mapillary API fails.\n        \"\"\"\n        if fields is None:\n            fields = self.FIELDS_LIST\n        else:\n            self._validate_fields(fields)\n        url = (\n            f\"{self.BASE_URL}/{image_id}\"\n            f\"?access_token={self.TOKEN}\"\n            f\"&amp;fields={','.join(fields)}\"\n        )\n        response = requests.get(url)\n        if response.status_code != 200:\n            raise Exception(\n                f\"Error connecting to Mapillary API. Exception: {response.text}\"\n            )\n        data = self._json_to_gdf([response.json()])\n        return GeoImageFrame(data, geometry=\"geometry\")\n\n    def fetch_by_sequence(self, sequence_ids, fields=None):\n        \"\"\"\n        Fetches images by their sequence IDs.\n\n        Args:\n            sequence_ids (list): The sequence IDs to fetch images from.\n            fields (list, optional): The fields to include in the response.\n\n        Returns:\n            GeoImageFrame: A GeoImageFrame containing the fetched images.\n\n        Raises:\n            Exception: If the connection to Mapillary API fails.\n        \"\"\"\n        if fields is None:\n            fields = self.FIELDS_LIST\n        else:\n            self._validate_fields(fields)\n        url = (\n            f\"{self.BASE_URL}/images\"\n            f\"?access_token={self.TOKEN}\"\n            f\"&amp;sequence_ids={','.join(sequence_ids)}\"\n            f\"&amp;fields={','.join(fields)}\"\n        )\n        response = requests.get(url)\n        if response.status_code != 200:\n            raise Exception(\n                f\"Error connecting to Mapillary API. Exception: {response.text}\"\n            )\n        response_data = response.json().get(\"data\")\n        if len(response_data) == self.LIMIT:\n            raise Exception(\n                \"Data count reached the limit. Please provide fewer sequence IDs.\"\n            )\n\n        data = self._json_to_gdf(response_data)\n        return GeoImageFrame(data, geometry=\"geometry\")\n\n    @staticmethod\n    def _get_timestamp(date_string, end_of_day=False):\n        \"\"\"\n        Converts a date string to a timestamp.\n\n        Args:\n            date_string (str): The date string to convert.\n            end_of_day (bool, optional): Whether to set the timestamp to the end of the day.\n\n        Returns:\n            str: The timestamp corresponding to the date string.\n        \"\"\"\n        if not date_string:\n            return None\n\n        tz = timezone.utc\n        dt = datetime.strptime(date_string, \"%Y-%m-%d\")\n        if end_of_day:\n            dt = dt.replace(hour=23, minute=59, second=59)\n        timestamp = (\n            dt.astimezone(tz).replace(microsecond=0).isoformat().replace(\"+00:00\", \"Z\")\n        )\n        return timestamp\n\n    def _process_timestamp(self, epoch_time_ms, lat, lng):\n        \"\"\"\n        Converts the given epoch time in milliseconds to an ISO-formatted timestamp adjusted to the local timezone\n        based on the provided latitude and longitude coordinates.\n\n        Args:\n            epoch_time_ms (int): Epoch time in milliseconds.\n            lat (float): Latitude coordinate for the timezone conversion.\n            lng (float): Longitude coordinate for the timezone conversion.\n\n        Returns:\n            str: An ISO-formatted timestamp in the local timezone if timezone information is found, otherwise in UTC.\n\n        Example:\n            &gt;&gt;&gt; _process_timestamp(1630456103000, 37.7749, -122.4194)\n            '2021-09-01T09:55:03-07:00'\n        \"\"\"\n        if not epoch_time_ms:\n            return None\n        epoch_time = epoch_time_ms / 1000\n        dt_utc = datetime.fromtimestamp(epoch_time, tz=timezone.utc)\n\n        tz_name = self.TF.timezone_at(lat=lat, lng=lng)\n        if tz_name:\n            local_tz = pytz.timezone(tz_name)\n            return dt_utc.astimezone(local_tz).isoformat()\n        else:\n            return dt_utc.isoformat()\n\n    def _recursive_fetch(\n        self,\n        bbox,\n        fields,\n        start_timestamp=None,\n        end_timestamp=None,\n        current_depth=0,\n        max_recursion_depth=None,\n    ):\n        \"\"\"\n        Recursively fetches images within a bounding box, considering timestamps.\n\n        Args:\n            bbox (list): The bounding box to fetch images from.\n            fields (list): The fields to include in the response.\n            start_timestamp (str, optional): The starting timestamp for filtering images.\n            end_timestamp (str, optional): The ending timestamp for filtering images.\n            current_depth (int, optional): Current depth of recursion.\n            max_recursion_depth (int, optional): Maximum depth of recursion.\n\n        Returns:\n            list: A list of image data.\n\n        Raises:\n            Exception: If the connection to Mapillary API fails.\n        \"\"\"\n        if max_recursion_depth is not None and current_depth &gt; max_recursion_depth:\n            warnings.warn(\n                \"Max recursion depth reached. Consider splitting requests.\"\n            )\n            return []\n\n        url = (\n            f\"{self.BASE_URL}/images\"\n            f\"?access_token={self.TOKEN}\"\n            f\"&amp;fields={','.join(fields)}\"\n            f\"&amp;bbox={','.join(str(i) for i in bbox)}\"\n            f\"&amp;limit={self.LIMIT}\"\n        )\n\n        if start_timestamp:\n            url += f\"&amp;start_captured_at={start_timestamp}\"\n        if end_timestamp:\n            url += f\"&amp;end_captured_at={end_timestamp}\"\n\n        response = requests.get(url)\n        if response.status_code != 200:\n            raise Exception(\n                f\"Error connecting to Mapillary API. Exception: {response.text}\"\n            )\n\n        response_data = response.json().get(\"data\")\n        if len(response_data) == self.LIMIT:\n            child_bboxes = self._split_bbox(bbox)\n            data = []\n            for child_bbox in child_bboxes:\n                data.extend(\n                    self._recursive_fetch(\n                        child_bbox,\n                        fields,\n                        start_timestamp,\n                        end_timestamp,\n                        current_depth=current_depth + 1,\n                        max_recursion_depth=max_recursion_depth,\n                    )\n                )\n            return data\n        else:\n            return response_data\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary.__init__","title":"<code>__init__(mapillary_token)</code>","text":"<p>Initialize a Mapillary object.</p> <p>Parameters:</p> Name Type Description Default <code>mapillary_token</code> <code>str</code> <p>The authentication token for Mapillary.</p> required Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>def __init__(self, mapillary_token):\n    \"\"\"\n    Initialize a Mapillary object.\n\n    Args:\n        mapillary_token (str): The authentication token for Mapillary.\n    \"\"\"\n    self.TOKEN = mapillary_token\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary._bbox_to_tile_coords","title":"<code>_bbox_to_tile_coords(bbox, zoom)</code>","text":"<p>Convert a bounding box to tile coordinates at a given zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list</code> <p>[west, south, east, north] coordinates</p> required <code>zoom</code> <code>int</code> <p>Zoom level</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(min_x, min_y, max_x, max_y) tile coordinates</p> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>def _bbox_to_tile_coords(self, bbox, zoom):\n    \"\"\"\n    Convert a bounding box to tile coordinates at a given zoom level.\n\n    Args:\n        bbox (list): [west, south, east, north] coordinates\n        zoom (int): Zoom level\n\n    Returns:\n        tuple: (min_x, min_y, max_x, max_y) tile coordinates\n    \"\"\"\n    def lat_to_tile_y(lat_deg, zoom):\n        lat_rad = math.radians(lat_deg)\n        n = 2.0 ** zoom\n        return int((1.0 - math.asinh(math.tan(lat_rad)) / math.pi) / 2.0 * n)\n\n    def lon_to_tile_x(lon_deg, zoom):\n        n = 2.0 ** zoom\n        return int((lon_deg + 180.0) / 360.0 * n)\n\n    west, south, east, north = bbox\n    min_x = lon_to_tile_x(west, zoom)\n    max_x = lon_to_tile_x(east, zoom)\n    min_y = lat_to_tile_y(north, zoom)  # Note: y coordinates are inverted\n    max_y = lat_to_tile_y(south, zoom)\n\n    return min_x, min_y, max_x, max_y\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary._extract_image_ids_from_features","title":"<code>_extract_image_ids_from_features(features)</code>","text":"<p>Extracts image IDs from tile features.</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>list</code> <p>List of features from a vector tile</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of image IDs</p> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>def _extract_image_ids_from_features(self, features):\n    \"\"\"\n    Extracts image IDs from tile features.\n\n    Args:\n        features (list): List of features from a vector tile\n\n    Returns:\n        list: List of image IDs\n    \"\"\"\n    image_ids = []\n\n    for feature in features:\n        if 'id' in feature.get('properties', {}):\n            image_ids.append(str(feature['properties']['id']))\n        elif 'image_id' in feature.get('properties', {}):\n            image_ids.append(str(feature['properties']['image_id']))\n\n    return image_ids\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary._fetch_coverage_tile","title":"<code>_fetch_coverage_tile(zoom, x, y)</code>","text":"<p>Fetches a single coverage tile.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>int</code> <p>Zoom level</p> required <code>x</code> <code>int</code> <p>Tile X coordinate</p> required <code>y</code> <code>int</code> <p>Tile Y coordinate</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Image features from the tile</p> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>def _fetch_coverage_tile(self, zoom, x, y):\n    \"\"\"\n    Fetches a single coverage tile.\n\n    Args:\n        zoom (int): Zoom level\n        x (int): Tile X coordinate\n        y (int): Tile Y coordinate\n\n    Returns:\n        list: Image features from the tile\n    \"\"\"\n    url = (\n        f\"{self.TILES_URL}/maps/vtp/mly1_public/2\"\n        f\"/{zoom}/{x}/{y}\"\n        f\"?access_token={self.TOKEN}\"\n    )\n\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            # Vector tiles are binary, not JSON\n            if 'application/x-protobuf' in response.headers.get('content-type', ''):\n                try:\n                    # Decode the vector tile\n                    tile_data = mapbox_vector_tile.decode(response.content)\n\n                    # Check for image layer at zoom level 14\n                    if 'image' in tile_data and zoom == 14:\n                        return tile_data['image']['features']\n\n                    # Check for sequence layer at zoom levels 6-14\n                    elif 'sequence' in tile_data and 6 &lt;= zoom &lt;= 14:\n                        return tile_data['sequence']['features']\n\n                    # Check for overview layer at zoom levels 0-5\n                    elif 'overview' in tile_data and 0 &lt;= zoom &lt;= 5:\n                        return tile_data['overview']['features']\n\n                    else:\n                        warnings.warn(f\"No usable layers found in tile {x},{y}\")\n                        return []\n\n                except Exception as e:\n                    warnings.warn(f\"Error decoding vector tile {x},{y}: {str(e)}\")\n                    return []\n            else:\n                warnings.warn(f\"Unexpected content type for tile {x},{y}\")\n                return []\n        else:\n            warnings.warn(f\"Error fetching tile {x},{y}: {response.status_code}\")\n            return []\n    except Exception as e:\n        warnings.warn(f\"Exception fetching tile {x},{y}: {str(e)}\")\n        return []\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary._fetch_image_metadata","title":"<code>_fetch_image_metadata(image_ids, fields, max_workers=10)</code>","text":"<p>Fetches metadata for multiple images using multi-threading.</p> <p>Parameters:</p> Name Type Description Default <code>image_ids</code> <code>list</code> <p>List of image IDs</p> required <code>fields</code> <code>list</code> <p>Fields to include in the response</p> required <code>max_workers</code> <code>int</code> <p>Maximum number of concurrent workers. Default is 10.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>list</code> <p>List of image metadata</p> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>def _fetch_image_metadata(self, image_ids, fields, max_workers=10):\n    \"\"\"\n    Fetches metadata for multiple images using multi-threading.\n\n    Args:\n        image_ids (list): List of image IDs\n        fields (list): Fields to include in the response\n        max_workers (int, optional): Maximum number of concurrent workers. Default is 10.\n\n    Returns:\n        list: List of image metadata\n    \"\"\"\n    results = []\n\n    def fetch_single_image(image_id):\n        url = (\n            f\"{self.BASE_URL}/{image_id}\"\n            f\"?access_token={self.TOKEN}\"\n            f\"&amp;fields={','.join(fields)}\"\n        )\n\n        try:\n            response = requests.get(url)\n            if response.status_code == 200:\n                return response.json()\n            else:\n                warnings.warn(f\"Error fetching image {image_id}: {response.status_code}\")\n                return None\n        except Exception as e:\n            warnings.warn(f\"Exception fetching image {image_id}: {str(e)}\")\n            return None\n\n    # Use ThreadPoolExecutor for parallel fetching\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        # Submit all tasks and create a map of future to image_id\n        future_to_id = {executor.submit(fetch_single_image, image_id): image_id\n                       for image_id in image_ids}\n\n        # Process results as they complete with a progress bar\n        for future in tqdm(as_completed(future_to_id),\n                          total=len(image_ids),\n                          desc=\"Fetching metadata\"):\n            result = future.result()\n            if result:\n                results.append(result)\n\n    return results\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary._get_timestamp","title":"<code>_get_timestamp(date_string, end_of_day=False)</code>  <code>staticmethod</code>","text":"<p>Converts a date string to a timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>date_string</code> <code>str</code> <p>The date string to convert.</p> required <code>end_of_day</code> <code>bool</code> <p>Whether to set the timestamp to the end of the day.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The timestamp corresponding to the date string.</p> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>@staticmethod\ndef _get_timestamp(date_string, end_of_day=False):\n    \"\"\"\n    Converts a date string to a timestamp.\n\n    Args:\n        date_string (str): The date string to convert.\n        end_of_day (bool, optional): Whether to set the timestamp to the end of the day.\n\n    Returns:\n        str: The timestamp corresponding to the date string.\n    \"\"\"\n    if not date_string:\n        return None\n\n    tz = timezone.utc\n    dt = datetime.strptime(date_string, \"%Y-%m-%d\")\n    if end_of_day:\n        dt = dt.replace(hour=23, minute=59, second=59)\n    timestamp = (\n        dt.astimezone(tz).replace(microsecond=0).isoformat().replace(\"+00:00\", \"Z\")\n    )\n    return timestamp\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary._json_to_gdf","title":"<code>_json_to_gdf(json_data)</code>","text":"<p>Converts JSON data from Mapillary to a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>json_data</code> <code>list</code> <p>A list of JSON data from Mapillary.</p> required <p>Returns:</p> Name Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame containing the image data.</p> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>def _json_to_gdf(self, json_data):\n    \"\"\"\n    Converts JSON data from Mapillary to a GeoDataFrame.\n\n    Args:\n        json_data (list): A list of JSON data from Mapillary.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame containing the image data.\n    \"\"\"\n    # Early return if no data\n    if not json_data:\n        return GeoDataFrame(geometry=[])\n\n    for img in json_data:\n        # Basic field conversions\n        coords = img.get(\"geometry\", {}).get(\"coordinates\", [None, None])\n        img[\"geometry\"] = Point(coords)\n        img[\"mly_id\"] = img.pop(\"id\")\n        img[\"name\"] = f\"mly|{img['mly_id']}\"\n\n        # Handle computed geometry\n        if \"computed_geometry\" in img:\n            coords = img.get(\"computed_geometry\", {}).get(\n                \"coordinates\", [None, None]\n            )\n            img[\"computed_geometry\"] = Point(coords)\n\n        # Process timestamp with timezone\n        if \"captured_at\" in img:\n            lat = img[\"geometry\"].y\n            lng = img[\"geometry\"].x\n            img[\"captured_at\"] = self._process_timestamp(\n                img.get(\"captured_at\"), lat, lng\n            )\n\n        # Set image URL from available options\n        image_url_found = False\n        for key in self.IMAGE_URL_KEYS:\n            if key in img:\n                img[\"image_url\"] = str(img.pop(key))  # Explicitly convert to string\n                image_url_found = True\n                break\n\n        # If no image URL was found, set a placeholder URL\n        # Instead of using a direct Mapillary API URL that might fail,\n        # we'll use a placeholder that indicates the image URL is missing\n        if not image_url_found:\n            img[\"image_url\"] = f\"placeholder://mapillary/{img['mly_id']}\"\n\n        # Convert list parameters to strings\n        for key in [\"camera_parameters\", \"computed_rotation\"]:\n            if key in img and isinstance(img[key], list):\n                img[key] = \",\".join(map(str, img[key]))\n\n        # Calculate quality score if not present\n        if \"quality_score\" not in img:\n            quality_score = 0.0\n            if \"computed_compass_angle\" in img:\n                quality_score += 0.5  # Good compass data\n            if \"atomic_scale\" in img:\n                quality_score += 0.3  # Good scale data\n            if img.get(\"camera_type\"):\n                quality_score += 0.2  # Camera type available\n            img[\"quality_score\"] = quality_score\n\n    # Create GeoDataFrame\n    gdf = GeoDataFrame(json_data, crs=\"EPSG:4326\")\n    gdf.set_geometry(\"geometry\", inplace=True)\n\n    # Sort by quality indicators and drop duplicates by sequence\n    if \"sequence\" in gdf.columns:\n        sort_columns = [col for col in self.QUALITY_INDICATORS if col in gdf.columns]\n        if sort_columns:\n            gdf = gdf.sort_values(sort_columns, ascending=False)\n            gdf = gdf.drop_duplicates(subset=['sequence'], keep='first')\n\n    # Ensure image_url is a string type\n    if \"image_url\" in gdf.columns:\n        gdf[\"image_url\"] = gdf[\"image_url\"].astype(str)\n\n    return gdf\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary._process_timestamp","title":"<code>_process_timestamp(epoch_time_ms, lat, lng)</code>","text":"<p>Converts the given epoch time in milliseconds to an ISO-formatted timestamp adjusted to the local timezone based on the provided latitude and longitude coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch_time_ms</code> <code>int</code> <p>Epoch time in milliseconds.</p> required <code>lat</code> <code>float</code> <p>Latitude coordinate for the timezone conversion.</p> required <code>lng</code> <code>float</code> <p>Longitude coordinate for the timezone conversion.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>An ISO-formatted timestamp in the local timezone if timezone information is found, otherwise in UTC.</p> Example <p>_process_timestamp(1630456103000, 37.7749, -122.4194) '2021-09-01T09:55:03-07:00'</p> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>def _process_timestamp(self, epoch_time_ms, lat, lng):\n    \"\"\"\n    Converts the given epoch time in milliseconds to an ISO-formatted timestamp adjusted to the local timezone\n    based on the provided latitude and longitude coordinates.\n\n    Args:\n        epoch_time_ms (int): Epoch time in milliseconds.\n        lat (float): Latitude coordinate for the timezone conversion.\n        lng (float): Longitude coordinate for the timezone conversion.\n\n    Returns:\n        str: An ISO-formatted timestamp in the local timezone if timezone information is found, otherwise in UTC.\n\n    Example:\n        &gt;&gt;&gt; _process_timestamp(1630456103000, 37.7749, -122.4194)\n        '2021-09-01T09:55:03-07:00'\n    \"\"\"\n    if not epoch_time_ms:\n        return None\n    epoch_time = epoch_time_ms / 1000\n    dt_utc = datetime.fromtimestamp(epoch_time, tz=timezone.utc)\n\n    tz_name = self.TF.timezone_at(lat=lat, lng=lng)\n    if tz_name:\n        local_tz = pytz.timezone(tz_name)\n        return dt_utc.astimezone(local_tz).isoformat()\n    else:\n        return dt_utc.isoformat()\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary._recursive_fetch","title":"<code>_recursive_fetch(bbox, fields, start_timestamp=None, end_timestamp=None, current_depth=0, max_recursion_depth=None)</code>","text":"<p>Recursively fetches images within a bounding box, considering timestamps.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list</code> <p>The bounding box to fetch images from.</p> required <code>fields</code> <code>list</code> <p>The fields to include in the response.</p> required <code>start_timestamp</code> <code>str</code> <p>The starting timestamp for filtering images.</p> <code>None</code> <code>end_timestamp</code> <code>str</code> <p>The ending timestamp for filtering images.</p> <code>None</code> <code>current_depth</code> <code>int</code> <p>Current depth of recursion.</p> <code>0</code> <code>max_recursion_depth</code> <code>int</code> <p>Maximum depth of recursion.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of image data.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the connection to Mapillary API fails.</p> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>def _recursive_fetch(\n    self,\n    bbox,\n    fields,\n    start_timestamp=None,\n    end_timestamp=None,\n    current_depth=0,\n    max_recursion_depth=None,\n):\n    \"\"\"\n    Recursively fetches images within a bounding box, considering timestamps.\n\n    Args:\n        bbox (list): The bounding box to fetch images from.\n        fields (list): The fields to include in the response.\n        start_timestamp (str, optional): The starting timestamp for filtering images.\n        end_timestamp (str, optional): The ending timestamp for filtering images.\n        current_depth (int, optional): Current depth of recursion.\n        max_recursion_depth (int, optional): Maximum depth of recursion.\n\n    Returns:\n        list: A list of image data.\n\n    Raises:\n        Exception: If the connection to Mapillary API fails.\n    \"\"\"\n    if max_recursion_depth is not None and current_depth &gt; max_recursion_depth:\n        warnings.warn(\n            \"Max recursion depth reached. Consider splitting requests.\"\n        )\n        return []\n\n    url = (\n        f\"{self.BASE_URL}/images\"\n        f\"?access_token={self.TOKEN}\"\n        f\"&amp;fields={','.join(fields)}\"\n        f\"&amp;bbox={','.join(str(i) for i in bbox)}\"\n        f\"&amp;limit={self.LIMIT}\"\n    )\n\n    if start_timestamp:\n        url += f\"&amp;start_captured_at={start_timestamp}\"\n    if end_timestamp:\n        url += f\"&amp;end_captured_at={end_timestamp}\"\n\n    response = requests.get(url)\n    if response.status_code != 200:\n        raise Exception(\n            f\"Error connecting to Mapillary API. Exception: {response.text}\"\n        )\n\n    response_data = response.json().get(\"data\")\n    if len(response_data) == self.LIMIT:\n        child_bboxes = self._split_bbox(bbox)\n        data = []\n        for child_bbox in child_bboxes:\n            data.extend(\n                self._recursive_fetch(\n                    child_bbox,\n                    fields,\n                    start_timestamp,\n                    end_timestamp,\n                    current_depth=current_depth + 1,\n                    max_recursion_depth=max_recursion_depth,\n                )\n            )\n        return data\n    else:\n        return response_data\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary._split_bbox","title":"<code>_split_bbox(inner_bbox)</code>  <code>staticmethod</code>","text":"<p>Splits a bounding box into four quarters.</p> <p>Parameters:</p> Name Type Description Default <code>inner_bbox</code> <code>list</code> <p>A list representing the bounding box to split.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of four bounding boxes, each representing a quarter.</p> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>@staticmethod\ndef _split_bbox(inner_bbox):\n    \"\"\"\n    Splits a bounding box into four quarters.\n\n    Args:\n        inner_bbox (list): A list representing the bounding box to split.\n\n    Returns:\n        list: A list of four bounding boxes, each representing a quarter.\n    \"\"\"\n    x1, y1, x2, y2 = inner_bbox[:]\n    xm = (x2 - x1) / 2\n    ym = (y2 - y1) / 2\n\n    q1 = [x1, y1, x1 + xm, y1 + ym]\n    q2 = [x1 + xm, y1, x2, y1 + ym]\n    q3 = [x1, y1 + ym, x1 + xm, y2]\n    q4 = [x1 + xm, y1 + ym, x2, y2]\n\n    return [q1, q2, q3, q4]\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary._tile_to_bbox","title":"<code>_tile_to_bbox(tile, zoom_level)</code>","text":"<p>Converts tile coordinates to a bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>tile</code> <code>dict</code> <p>Tile coordinates (x, y).</p> required <code>zoom_level</code> <code>int</code> <p>The zoom level of the tile.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Bounding box coordinates [west, south, east, north].</p> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>def _tile_to_bbox(self, tile, zoom_level):\n    \"\"\"\n    Converts tile coordinates to a bounding box.\n\n    Args:\n        tile (dict): Tile coordinates (x, y).\n        zoom_level (int): The zoom level of the tile.\n\n    Returns:\n        list: Bounding box coordinates [west, south, east, north].\n    \"\"\"\n    x, y = tile['x'], tile['y']\n    n = 2.0 ** zoom_level\n    west = x / n * 360.0 - 180.0\n    east = (x + 1) / n * 360.0 - 180.0\n\n    def inv_lat(y_tile):\n        return math.degrees(math.atan(math.sinh(math.pi * (1 - 2 * y_tile / n))))\n\n    north = inv_lat(y)\n    south = inv_lat(y + 1)\n\n    return [west, south, east, north]\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary._validate_fields","title":"<code>_validate_fields(fields)</code>","text":"<p>Validates the fields for fetching data.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>list</code> <p>The fields to be validated.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the required fields are missing.</p> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>def _validate_fields(self, fields):\n    \"\"\"\n    Validates the fields for fetching data.\n\n    Args:\n        fields (list): The fields to be validated.\n\n    Raises:\n        ValueError: If the required fields are missing.\n    \"\"\"\n    if (\n        \"id\" not in fields\n        or \"geometry\" not in fields\n        or not any(image_field in fields for image_field in self.IMAGE_URL_KEYS)\n    ):\n        raise ValueError(\n            \"Fields must contain 'id', 'geometry', and one of \"\n            + str(self.IMAGE_URL_KEYS)\n        )\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary.fetch_by_id","title":"<code>fetch_by_id(image_id, fields=None)</code>","text":"<p>Fetches an image by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>image_id</code> <code>str</code> <p>The ID of the image to fetch.</p> required <code>fields</code> <code>list</code> <p>The fields to include in the response.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>GeoImageFrame</code> <p>A GeoImageFrame containing the fetched image.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the connection to Mapillary API fails.</p> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>def fetch_by_id(self, image_id, fields=None):\n    \"\"\"\n    Fetches an image by its ID.\n\n    Args:\n        image_id (str): The ID of the image to fetch.\n        fields (list, optional): The fields to include in the response.\n\n    Returns:\n        GeoImageFrame: A GeoImageFrame containing the fetched image.\n\n    Raises:\n        Exception: If the connection to Mapillary API fails.\n    \"\"\"\n    if fields is None:\n        fields = self.FIELDS_LIST\n    else:\n        self._validate_fields(fields)\n    url = (\n        f\"{self.BASE_URL}/{image_id}\"\n        f\"?access_token={self.TOKEN}\"\n        f\"&amp;fields={','.join(fields)}\"\n    )\n    response = requests.get(url)\n    if response.status_code != 200:\n        raise Exception(\n            f\"Error connecting to Mapillary API. Exception: {response.text}\"\n        )\n    data = self._json_to_gdf([response.json()])\n    return GeoImageFrame(data, geometry=\"geometry\")\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary.fetch_by_sequence","title":"<code>fetch_by_sequence(sequence_ids, fields=None)</code>","text":"<p>Fetches images by their sequence IDs.</p> <p>Parameters:</p> Name Type Description Default <code>sequence_ids</code> <code>list</code> <p>The sequence IDs to fetch images from.</p> required <code>fields</code> <code>list</code> <p>The fields to include in the response.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>GeoImageFrame</code> <p>A GeoImageFrame containing the fetched images.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the connection to Mapillary API fails.</p> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>def fetch_by_sequence(self, sequence_ids, fields=None):\n    \"\"\"\n    Fetches images by their sequence IDs.\n\n    Args:\n        sequence_ids (list): The sequence IDs to fetch images from.\n        fields (list, optional): The fields to include in the response.\n\n    Returns:\n        GeoImageFrame: A GeoImageFrame containing the fetched images.\n\n    Raises:\n        Exception: If the connection to Mapillary API fails.\n    \"\"\"\n    if fields is None:\n        fields = self.FIELDS_LIST\n    else:\n        self._validate_fields(fields)\n    url = (\n        f\"{self.BASE_URL}/images\"\n        f\"?access_token={self.TOKEN}\"\n        f\"&amp;sequence_ids={','.join(sequence_ids)}\"\n        f\"&amp;fields={','.join(fields)}\"\n    )\n    response = requests.get(url)\n    if response.status_code != 200:\n        raise Exception(\n            f\"Error connecting to Mapillary API. Exception: {response.text}\"\n        )\n    response_data = response.json().get(\"data\")\n    if len(response_data) == self.LIMIT:\n        raise Exception(\n            \"Data count reached the limit. Please provide fewer sequence IDs.\"\n        )\n\n    data = self._json_to_gdf(response_data)\n    return GeoImageFrame(data, geometry=\"geometry\")\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.cloud.Mapillary.fetch_within_bbox","title":"<code>fetch_within_bbox(initial_bbox, start_date=None, end_date=None, fields=None, max_recursion_depth=25, use_coverage_tiles=True, max_images=5000, max_workers=10)</code>","text":"<p>Fetches images within a bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>initial_bbox</code> <code>list</code> <p>The bounding box to fetch images from [west, south, east, north].</p> required <code>start_date</code> <code>str</code> <p>Start date for filtering images (YYYY-MM-DD).</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date for filtering images (YYYY-MM-DD).</p> <code>None</code> <code>fields</code> <code>list</code> <p>Fields to include in the response.</p> <code>None</code> <code>max_recursion_depth</code> <code>int</code> <p>Maximum depth for recursive fetching.</p> <code>25</code> <code>use_coverage_tiles</code> <code>bool</code> <p>Whether to use coverage tiles API for large areas.</p> <code>True</code> <code>max_images</code> <code>int</code> <p>Maximum number of images to process. Default is 5000.</p> <code>5000</code> <code>max_workers</code> <code>int</code> <p>Maximum number of concurrent workers. Default is 10.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>GeoImageFrame</code> <p>A GeoImageFrame containing the image data.</p> Source code in <code>landlensdb/handlers/cloud.py</code> <pre><code>def fetch_within_bbox(\n    self,\n    initial_bbox,\n    start_date=None,\n    end_date=None,\n    fields=None,\n    max_recursion_depth=25,\n    use_coverage_tiles=True,\n    max_images=5000,\n    max_workers=10\n):\n    \"\"\"\n    Fetches images within a bounding box.\n\n    Args:\n        initial_bbox (list): The bounding box to fetch images from [west, south, east, north].\n        start_date (str, optional): Start date for filtering images (YYYY-MM-DD).\n        end_date (str, optional): End date for filtering images (YYYY-MM-DD).\n        fields (list, optional): Fields to include in the response.\n        max_recursion_depth (int, optional): Maximum depth for recursive fetching.\n        use_coverage_tiles (bool, optional): Whether to use coverage tiles API for large areas.\n        max_images (int, optional): Maximum number of images to process. Default is 5000.\n        max_workers (int, optional): Maximum number of concurrent workers. Default is 10.\n\n    Returns:\n        GeoImageFrame: A GeoImageFrame containing the image data.\n    \"\"\"\n    if fields is None:\n        fields = self.FIELDS_LIST\n\n    # Ensure required fields are included\n    if \"id\" not in fields:\n        fields.append(\"id\")\n    if \"geometry\" not in fields:\n        fields.append(\"geometry\")\n    if not any(url_key in fields for url_key in self.IMAGE_URL_KEYS):\n        fields.append(\"thumb_1024_url\")\n\n    start_timestamp = self._get_timestamp(start_date) if start_date else None\n    end_timestamp = self._get_timestamp(end_date, True) if end_date else None\n\n    if use_coverage_tiles:\n        # Get coverage tiles for the area\n        min_x, min_y, max_x, max_y = self._bbox_to_tile_coords(initial_bbox, self.ZOOM_LEVEL)\n\n        all_image_ids = []\n        print(f\"Fetching {(max_x - min_x + 1) * (max_y - min_y + 1)} tiles...\")\n\n        # Fetch all tiles in the bounding box\n        for x in range(min_x, max_x + 1):\n            for y in range(min_y, max_y + 1):\n                features = self._fetch_coverage_tile(self.ZOOM_LEVEL, x, y)\n                image_ids = self._extract_image_ids_from_features(features)\n                all_image_ids.extend(image_ids)\n\n                # Check if we've reached the maximum number of images\n                if len(all_image_ids) &gt;= max_images * 2:  # Get more than needed to allow for filtering\n                    print(f\"Reached maximum number of images ({max_images}), stopping tile fetching\")\n                    break\n\n            # Check again after processing a row of tiles\n            if len(all_image_ids) &gt;= max_images * 2:\n                break\n\n        print(f\"Found {len(all_image_ids)} total images\")\n\n        # Remove duplicates\n        all_image_ids = list(set(all_image_ids))\n        print(f\"After removing duplicates: {len(all_image_ids)} unique images\")\n\n        # Limit the number of images to process\n        if len(all_image_ids) &gt; max_images:\n            print(f\"Limiting to {max_images} images for processing\")\n            all_image_ids = all_image_ids[:max_images]\n\n        # Fetch metadata for all images using multi-threading\n        all_data = self._fetch_image_metadata(all_image_ids, fields, max_workers=max_workers)\n\n        data = self._json_to_gdf(all_data)\n        return GeoImageFrame(data, geometry=\"geometry\")\n    else:\n        # Use traditional recursive fetching\n        data = self._recursive_fetch(\n            initial_bbox,\n            fields,\n            start_timestamp,\n            end_timestamp,\n            max_recursion_depth=max_recursion_depth\n        )\n        gdf = self._json_to_gdf(data)\n        return GeoImageFrame(gdf, geometry=\"geometry\")\n</code></pre>"},{"location":"api/handlers/#db-handler","title":"DB Handler","text":""},{"location":"api/handlers/#landlensdb.handlers.db.Postgres","title":"<code>Postgres</code>","text":"<p>A class for managing image-related postgres database operations.</p> <p>Attributes:</p> Name Type Description <code>DATABASE_URL</code> <code>str</code> <p>The URL of the database to connect to.</p> <code>engine</code> <code>Engine</code> <p>SQLAlchemy engine for database connections.</p> <code>result_set</code> <code>ResultProxy</code> <p>The result of the last query executed.</p> <code>selected_table</code> <code>Table</code> <p>The table object for query operations.</p> Source code in <code>landlensdb/handlers/db.py</code> <pre><code>class Postgres:\n    \"\"\"\n    A class for managing image-related postgres database operations.\n\n    Attributes:\n        DATABASE_URL (str): The URL of the database to connect to.\n        engine (Engine): SQLAlchemy engine for database connections.\n        result_set (ResultProxy): The result of the last query executed.\n        selected_table (Table): The table object for query operations.\n    \"\"\"\n\n    def __init__(self, database_url):\n        \"\"\"\n        Initializes the ImageDB class with the given database URL.\n\n        Args:\n            database_url (str): The URL of the database to connect to.\n        \"\"\"\n        self.DATABASE_URL = database_url\n        self.engine = create_engine(self.DATABASE_URL)\n        self.result_set = None\n        self.selected_table = None\n\n    @staticmethod\n    def _convert_points_to_wkt(record):\n        \"\"\"\n        Converts Point objects to WKT (Well-Known Text) format.\n\n        Args:\n            record (dict): A dictionary containing keys and values, where values can be Point objects.\n\n        Returns:\n            dict: The record with Point objects converted to WKT strings.\n        \"\"\"\n        for key, value in record.items():\n            if isinstance(value, Point):\n                record[key] = value.wkt\n        return record\n\n    @staticmethod\n    def _convert_dicts_to_json(record):\n        \"\"\"\n        Converts dictionary values in a record to JSON strings.\n\n        Args:\n            record (dict): A dictionary where values may include other dictionaries.\n\n        Returns:\n            dict: The modified record with dict values converted to JSON strings.\n        \"\"\"\n        for key, value in record.items():\n            if isinstance(value, dict):\n                record[key] = json.dumps(value)\n        return record\n\n    def table(self, table_name):\n        \"\"\"\n        Selects a table for performing queries on.\n\n        Args:\n            table_name (str): Name of the table to select.\n\n        Returns:\n            ImageDB: Returns self to enable method chaining.\n        \"\"\"\n        metadata = MetaData()\n        self.selected_table = Table(table_name, metadata, autoload_with=self.engine)\n        self.result_set = self.selected_table.select()\n        return self\n\n    def filter(self, **kwargs):\n        \"\"\"\n        Applies filters to the selected table based on provided conditions.\n\n        Args:\n            **kwargs: Key-value pairs representing filters to apply.\n\n        Returns:\n            ImageDB: Returns self to enable method chaining.\n\n        Raises:\n            ValueError: If an unsupported operation or a nonexistent column is specified.\n        \"\"\"\n        filters = []\n\n        for k, v in kwargs.items():\n            if \"__\" in k:\n                field_name, operation = k.split(\"__\", 1)\n            else:\n                field_name = k\n                operation = \"eq\"\n\n            column = getattr(self.selected_table.columns, field_name, None)\n            if column is None:\n                raise ValueError(\n                    f\"Column '{field_name}' not found in table '{self.selected_table.name}'\"\n                )\n\n            if operation == \"eq\":\n                filters.append(column == v)\n            elif operation == \"gt\":\n                filters.append(column &gt; v)\n            elif operation == \"lt\":\n                filters.append(column &lt; v)\n            elif operation == \"gte\":\n                filters.append(column &gt;= v)\n            elif operation == \"lte\":\n                filters.append(column &lt;= v)\n            else:\n                raise ValueError(f\"Unsupported operation '{operation}'\")\n\n        self.result_set = self.result_set.where(and_(*filters))\n        return self\n\n    def all(self):\n        \"\"\"\n        Executes the query and returns the result as a GeoImageFrame.\n\n        Returns:\n            GeoImageFrame: The result of the query as a GeoImageFrame object.\n\n        Raises:\n            TypeError: If geometries are not of type Point.\n        \"\"\"\n        with self.engine.connect() as conn:\n            result = conn.execute(self.result_set)\n            data = [row._asdict() for row in result.fetchall()]\n\n        if not data:\n            return GeoImageFrame([])  # Adjust according to your GeoImageFrame handling\n\n        df_data = {col: [] for col in data[0].keys()}\n\n        for d in data:\n            for col, value in d.items():\n                if isinstance(value, WKBElement):\n                    try:\n                        point_geom = loads(\n                            bytes(value.data)\n                        )  # convert WKBElement to Shapely geometry\n                        if point_geom.geom_type != \"Point\":\n                            raise TypeError(\"All geometries must be of type Point.\")\n                        df_data[col].append(point_geom)\n                    except Exception as e:\n                        print(f\"Failed to process data {value.data}. Error: {e}\")\n                else:\n                    df_data[col].append(value)\n\n        return GeoImageFrame(df_data)\n\n    def get_distinct_values(self, table_name, column_name):\n        \"\"\"\n        Gets distinct values from a specific column of a table.\n\n        Args:\n            table_name (str): Name of the table to query.\n            column_name (str): Name of the column to get distinct values from.\n\n        Returns:\n            list: A list of distinct values from the specified column.\n\n        Raises:\n            ValueError: If the specified column is not found in the table.\n        \"\"\"\n        metadata = MetaData()\n        metadata.reflect(bind=self.engine)\n\n        if table_name not in metadata.tables:\n            raise ValueError(f\"Table '{table_name}' not found.\")\n\n        table = metadata.tables[table_name]\n\n        if column_name not in table.columns:\n            raise ValueError(\n                f\"Column '{column_name}' not found in table '{table_name}'\"\n            )\n\n        column = table.columns[column_name]\n\n        distinct_query = select(column).distinct()\n        with self.engine.connect() as conn:\n            result = conn.execute(distinct_query)\n\n        distinct_values = [row[0] for row in result.fetchall()]\n        return distinct_values\n\n    def upsert_images(self, gif, table_name, conflict=\"update\"):\n        \"\"\"\n        Inserts or updates image data in the specified table.\n\n        Args:\n            gif (GeoImageFrame): The data frame containing image data.\n            table_name (str): The name of the table to upsert into.\n            conflict (str, optional): Conflict resolution strategy (\"update\" or \"nothing\"). Defaults to \"update\".\n\n        Raises:\n            ValueError: If an invalid conflict resolution type is provided.\n        \"\"\"\n        data = gif.to_dict(orient=\"records\")\n\n        meta = MetaData()\n        table = Table(table_name, meta, autoload_with=self.engine)\n\n        with self.engine.begin() as conn:\n            for record in data:\n                record = self._convert_points_to_wkt(record)\n                record = self._convert_dicts_to_json(record)\n                insert_stmt = insert(table).values(**record)\n                if conflict == \"update\":\n                    updates = {\n                        key: getattr(insert_stmt.excluded, key)\n                        for key in record\n                        if key != \"image_url\"\n                    }\n                    constraint_name = f\"{table.name}_image_url_key\"\n                    on_conflict_stmt = insert_stmt.on_conflict_do_update(\n                        constraint=constraint_name,\n                        set_=updates\n                    )\n                elif conflict == \"nothing\":\n                    on_conflict_stmt = insert_stmt.on_conflict_do_nothing()\n                else:\n                    raise ValueError(\n                        \"Invalid conflict resolution type. Choose 'update' or 'nothing'.\"\n                    )\n\n                conn.execute(on_conflict_stmt)\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.db.Postgres.__init__","title":"<code>__init__(database_url)</code>","text":"<p>Initializes the ImageDB class with the given database URL.</p> <p>Parameters:</p> Name Type Description Default <code>database_url</code> <code>str</code> <p>The URL of the database to connect to.</p> required Source code in <code>landlensdb/handlers/db.py</code> <pre><code>def __init__(self, database_url):\n    \"\"\"\n    Initializes the ImageDB class with the given database URL.\n\n    Args:\n        database_url (str): The URL of the database to connect to.\n    \"\"\"\n    self.DATABASE_URL = database_url\n    self.engine = create_engine(self.DATABASE_URL)\n    self.result_set = None\n    self.selected_table = None\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.db.Postgres._convert_dicts_to_json","title":"<code>_convert_dicts_to_json(record)</code>  <code>staticmethod</code>","text":"<p>Converts dictionary values in a record to JSON strings.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>dict</code> <p>A dictionary where values may include other dictionaries.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The modified record with dict values converted to JSON strings.</p> Source code in <code>landlensdb/handlers/db.py</code> <pre><code>@staticmethod\ndef _convert_dicts_to_json(record):\n    \"\"\"\n    Converts dictionary values in a record to JSON strings.\n\n    Args:\n        record (dict): A dictionary where values may include other dictionaries.\n\n    Returns:\n        dict: The modified record with dict values converted to JSON strings.\n    \"\"\"\n    for key, value in record.items():\n        if isinstance(value, dict):\n            record[key] = json.dumps(value)\n    return record\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.db.Postgres._convert_points_to_wkt","title":"<code>_convert_points_to_wkt(record)</code>  <code>staticmethod</code>","text":"<p>Converts Point objects to WKT (Well-Known Text) format.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>dict</code> <p>A dictionary containing keys and values, where values can be Point objects.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The record with Point objects converted to WKT strings.</p> Source code in <code>landlensdb/handlers/db.py</code> <pre><code>@staticmethod\ndef _convert_points_to_wkt(record):\n    \"\"\"\n    Converts Point objects to WKT (Well-Known Text) format.\n\n    Args:\n        record (dict): A dictionary containing keys and values, where values can be Point objects.\n\n    Returns:\n        dict: The record with Point objects converted to WKT strings.\n    \"\"\"\n    for key, value in record.items():\n        if isinstance(value, Point):\n            record[key] = value.wkt\n    return record\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.db.Postgres.all","title":"<code>all()</code>","text":"<p>Executes the query and returns the result as a GeoImageFrame.</p> <p>Returns:</p> Name Type Description <code>GeoImageFrame</code> <p>The result of the query as a GeoImageFrame object.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If geometries are not of type Point.</p> Source code in <code>landlensdb/handlers/db.py</code> <pre><code>def all(self):\n    \"\"\"\n    Executes the query and returns the result as a GeoImageFrame.\n\n    Returns:\n        GeoImageFrame: The result of the query as a GeoImageFrame object.\n\n    Raises:\n        TypeError: If geometries are not of type Point.\n    \"\"\"\n    with self.engine.connect() as conn:\n        result = conn.execute(self.result_set)\n        data = [row._asdict() for row in result.fetchall()]\n\n    if not data:\n        return GeoImageFrame([])  # Adjust according to your GeoImageFrame handling\n\n    df_data = {col: [] for col in data[0].keys()}\n\n    for d in data:\n        for col, value in d.items():\n            if isinstance(value, WKBElement):\n                try:\n                    point_geom = loads(\n                        bytes(value.data)\n                    )  # convert WKBElement to Shapely geometry\n                    if point_geom.geom_type != \"Point\":\n                        raise TypeError(\"All geometries must be of type Point.\")\n                    df_data[col].append(point_geom)\n                except Exception as e:\n                    print(f\"Failed to process data {value.data}. Error: {e}\")\n            else:\n                df_data[col].append(value)\n\n    return GeoImageFrame(df_data)\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.db.Postgres.filter","title":"<code>filter(**kwargs)</code>","text":"<p>Applies filters to the selected table based on provided conditions.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Key-value pairs representing filters to apply.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ImageDB</code> <p>Returns self to enable method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported operation or a nonexistent column is specified.</p> Source code in <code>landlensdb/handlers/db.py</code> <pre><code>def filter(self, **kwargs):\n    \"\"\"\n    Applies filters to the selected table based on provided conditions.\n\n    Args:\n        **kwargs: Key-value pairs representing filters to apply.\n\n    Returns:\n        ImageDB: Returns self to enable method chaining.\n\n    Raises:\n        ValueError: If an unsupported operation or a nonexistent column is specified.\n    \"\"\"\n    filters = []\n\n    for k, v in kwargs.items():\n        if \"__\" in k:\n            field_name, operation = k.split(\"__\", 1)\n        else:\n            field_name = k\n            operation = \"eq\"\n\n        column = getattr(self.selected_table.columns, field_name, None)\n        if column is None:\n            raise ValueError(\n                f\"Column '{field_name}' not found in table '{self.selected_table.name}'\"\n            )\n\n        if operation == \"eq\":\n            filters.append(column == v)\n        elif operation == \"gt\":\n            filters.append(column &gt; v)\n        elif operation == \"lt\":\n            filters.append(column &lt; v)\n        elif operation == \"gte\":\n            filters.append(column &gt;= v)\n        elif operation == \"lte\":\n            filters.append(column &lt;= v)\n        else:\n            raise ValueError(f\"Unsupported operation '{operation}'\")\n\n    self.result_set = self.result_set.where(and_(*filters))\n    return self\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.db.Postgres.get_distinct_values","title":"<code>get_distinct_values(table_name, column_name)</code>","text":"<p>Gets distinct values from a specific column of a table.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table to query.</p> required <code>column_name</code> <code>str</code> <p>Name of the column to get distinct values from.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of distinct values from the specified column.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified column is not found in the table.</p> Source code in <code>landlensdb/handlers/db.py</code> <pre><code>def get_distinct_values(self, table_name, column_name):\n    \"\"\"\n    Gets distinct values from a specific column of a table.\n\n    Args:\n        table_name (str): Name of the table to query.\n        column_name (str): Name of the column to get distinct values from.\n\n    Returns:\n        list: A list of distinct values from the specified column.\n\n    Raises:\n        ValueError: If the specified column is not found in the table.\n    \"\"\"\n    metadata = MetaData()\n    metadata.reflect(bind=self.engine)\n\n    if table_name not in metadata.tables:\n        raise ValueError(f\"Table '{table_name}' not found.\")\n\n    table = metadata.tables[table_name]\n\n    if column_name not in table.columns:\n        raise ValueError(\n            f\"Column '{column_name}' not found in table '{table_name}'\"\n        )\n\n    column = table.columns[column_name]\n\n    distinct_query = select(column).distinct()\n    with self.engine.connect() as conn:\n        result = conn.execute(distinct_query)\n\n    distinct_values = [row[0] for row in result.fetchall()]\n    return distinct_values\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.db.Postgres.table","title":"<code>table(table_name)</code>","text":"<p>Selects a table for performing queries on.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table to select.</p> required <p>Returns:</p> Name Type Description <code>ImageDB</code> <p>Returns self to enable method chaining.</p> Source code in <code>landlensdb/handlers/db.py</code> <pre><code>def table(self, table_name):\n    \"\"\"\n    Selects a table for performing queries on.\n\n    Args:\n        table_name (str): Name of the table to select.\n\n    Returns:\n        ImageDB: Returns self to enable method chaining.\n    \"\"\"\n    metadata = MetaData()\n    self.selected_table = Table(table_name, metadata, autoload_with=self.engine)\n    self.result_set = self.selected_table.select()\n    return self\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.db.Postgres.upsert_images","title":"<code>upsert_images(gif, table_name, conflict='update')</code>","text":"<p>Inserts or updates image data in the specified table.</p> <p>Parameters:</p> Name Type Description Default <code>gif</code> <code>GeoImageFrame</code> <p>The data frame containing image data.</p> required <code>table_name</code> <code>str</code> <p>The name of the table to upsert into.</p> required <code>conflict</code> <code>str</code> <p>Conflict resolution strategy (\"update\" or \"nothing\"). Defaults to \"update\".</p> <code>'update'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid conflict resolution type is provided.</p> Source code in <code>landlensdb/handlers/db.py</code> <pre><code>def upsert_images(self, gif, table_name, conflict=\"update\"):\n    \"\"\"\n    Inserts or updates image data in the specified table.\n\n    Args:\n        gif (GeoImageFrame): The data frame containing image data.\n        table_name (str): The name of the table to upsert into.\n        conflict (str, optional): Conflict resolution strategy (\"update\" or \"nothing\"). Defaults to \"update\".\n\n    Raises:\n        ValueError: If an invalid conflict resolution type is provided.\n    \"\"\"\n    data = gif.to_dict(orient=\"records\")\n\n    meta = MetaData()\n    table = Table(table_name, meta, autoload_with=self.engine)\n\n    with self.engine.begin() as conn:\n        for record in data:\n            record = self._convert_points_to_wkt(record)\n            record = self._convert_dicts_to_json(record)\n            insert_stmt = insert(table).values(**record)\n            if conflict == \"update\":\n                updates = {\n                    key: getattr(insert_stmt.excluded, key)\n                    for key in record\n                    if key != \"image_url\"\n                }\n                constraint_name = f\"{table.name}_image_url_key\"\n                on_conflict_stmt = insert_stmt.on_conflict_do_update(\n                    constraint=constraint_name,\n                    set_=updates\n                )\n            elif conflict == \"nothing\":\n                on_conflict_stmt = insert_stmt.on_conflict_do_nothing()\n            else:\n                raise ValueError(\n                    \"Invalid conflict resolution type. Choose 'update' or 'nothing'.\"\n                )\n\n            conn.execute(on_conflict_stmt)\n</code></pre>"},{"location":"api/handlers/#image-handler","title":"Image Handler","text":""},{"location":"api/handlers/#landlensdb.handlers.image.Local","title":"<code>Local</code>","text":"<p>A class to process EXIF data from images, mainly focusing on extracting geotagging information.</p> <p>This class includes methods to extract various camera and image properties, such as focal length, camera type, coordinates, and other related data.</p> Source code in <code>landlensdb/handlers/image.py</code> <pre><code>class Local:\n    \"\"\"\n    A class to process EXIF data from images, mainly focusing on extracting geotagging information.\n\n    This class includes methods to extract various camera and image properties, such as focal length,\n    camera type, coordinates, and other related data.\n    \"\"\"\n\n    @staticmethod\n    def _get_camera_model(exif_data):\n        \"\"\"\n        Extracts the camera model from the EXIF data.\n\n        Args:\n            exif_data (dict): The EXIF data.\n\n        Returns:\n            str: Camera model if available, otherwise None.\n        \"\"\"\n        return exif_data.get(\"Model\", \"\").strip()\n\n    @staticmethod\n    def _infer_camera_type(focal_length, camera_model=None):\n        \"\"\"\n        Infers the camera type based on the focal length and camera model.\n\n        Args:\n            focal_length (float): The focal length of the camera.\n            camera_model (str): The camera model.\n\n        Returns:\n            str: One of \"fisheye\", \"perspective\", or \"360-degree\".\n        \"\"\"\n        if not focal_length and not camera_model:\n            return np.nan\n\n        known_360_cameras = KNOWN_CAMERAS.get(\"360 Models\", [])\n\n        if camera_model in known_360_cameras:\n            return \"360-degree\"\n\n        # Further classification based on focal length\n        if focal_length &lt; 1.5:\n            return \"fisheye\"\n        else:\n            return \"perspective\"\n\n    @staticmethod\n    def get_exif_data(img):\n        \"\"\"\n        Retrieves the EXIF data from an image.\n\n        Args:\n            img (PIL.Image.Image): The image to extract EXIF data from.\n\n        Returns:\n            dict: A dictionary containing the EXIF data.\n        \"\"\"\n        exif_data = {}\n        info = img._getexif()\n        if info:\n            for tag, value in info.items():\n                tag_name = TAGS.get(tag, tag)\n                if tag_name == \"GPSInfo\":\n                    gps_info = {}\n                    for t in value:\n                        sub_tag_name = GPSTAGS.get(t, t)\n                        gps_info[sub_tag_name] = value[t]\n                    exif_data[tag_name] = gps_info\n                else:\n                    exif_data[tag_name] = value\n        return exif_data\n\n    @staticmethod\n    def create_thumbnail(image_path, size=(256, 256)):\n        \"\"\"\n        Creates a thumbnail for the given image while preserving aspect ratio.\n\n        Args:\n            image_path (str): Path to the original image\n            size (tuple): Desired thumbnail size as (width, height). Default is (256, 256)\n\n        Returns:\n            str: Path to the created thumbnail\n\n        Raises:\n            FileNotFoundError: If the image file doesn't exist\n            ValueError: If the image cannot be opened or processed\n        \"\"\"\n        if not os.path.exists(image_path):\n            raise FileNotFoundError(f\"Image file not found: {image_path}\")\n\n        # Create thumbnails directory in the same directory as the original image\n        original_dir = os.path.dirname(image_path)\n        thumbnail_dir = os.path.join(original_dir, \"thumbnails\")\n        os.makedirs(thumbnail_dir, exist_ok=True)\n\n        # Generate thumbnail filename\n        original_filename = os.path.basename(image_path)\n        thumbnail_filename = f\"thumb_{original_filename}\"\n        thumbnail_path = os.path.join(thumbnail_dir, thumbnail_filename)\n\n        try:\n            with Image.open(image_path) as img:\n                # Convert to RGB if necessary\n                if img.mode in ('RGBA', 'LA'):\n                    img = img.convert('RGB')\n\n                # Calculate new dimensions preserving aspect ratio\n                img.thumbnail(size, Image.Resampling.LANCZOS)\n\n                # Save thumbnail\n                img.save(thumbnail_path, \"JPEG\", quality=85)\n                return thumbnail_path\n\n        except Exception as e:\n            raise ValueError(f\"Error creating thumbnail for {image_path}: {str(e)}\")\n\n    @staticmethod\n    def _to_decimal(coord_tuple):\n        \"\"\"\n        Converts coordinates from degrees, minutes, and seconds to decimal.\n\n        Args:\n            coord_tuple (tuple or str): The coordinate tuple to convert.\n\n        Returns:\n            float: Decimal representation of the coordinates.\n        \"\"\"\n        if isinstance(coord_tuple, tuple) and len(coord_tuple) == 3:\n            return (\n                float(coord_tuple[0])\n                + float(coord_tuple[1]) / 60\n                + float(coord_tuple[2]) / 3600\n            )\n        elif isinstance(coord_tuple, str) and \"/\" in coord_tuple:\n            num, denom = coord_tuple.split(\"/\")\n            if float(denom) != 0:\n                return float(num) / float(denom)\n            else:\n                return None\n        return coord_tuple\n\n    @classmethod\n    def _get_geotagging(cls, exif):\n        \"\"\"\n        Extracts geotagging information from EXIF metadata.\n\n        Args:\n            exif (dict): The EXIF metadata.\n\n        Returns:\n            dict: A dictionary containing the geotagging information.\n\n        Raises:\n            ValueError: If no EXIF metadata found or no GPSInfo tag found.\n        \"\"\"\n        if not exif:\n            raise ValueError(\"No EXIF metadata found\")\n\n        idx = None\n        for tag, label in TAGS.items():\n            if label == \"GPSInfo\":\n                idx = tag\n                break\n\n        if idx is None:\n            raise ValueError(\"No GPSInfo tag found in TAGS.\")\n\n        gps_data = exif.get(\"GPSInfo\", exif.get(idx, None))\n        if not gps_data:\n            raise ValueError(\"No EXIF geotagging found\")\n\n        geotagging = {}\n        for key, val in GPSTAGS.items():\n            data_value = gps_data.get(key) or gps_data.get(val)\n            if data_value:\n                geotagging[val] = data_value\n\n        return geotagging\n\n    @classmethod\n    def _get_image_altitude(cls, geotags):\n        \"\"\"\n        Retrieves the altitude information from geotags.\n\n        Args:\n            geotags (dict): The geotags information.\n\n        Returns:\n            float: Altitude information if available, otherwise None.\n        \"\"\"\n        if \"GPSAltitude\" in geotags:\n            return geotags[\"GPSAltitude\"]\n        return None\n\n    @classmethod\n    def _get_image_direction(cls, geotags):\n        \"\"\"\n        Retrieves the image direction information from geotags.\n\n        Args:\n            geotags (dict): The geotags information.\n\n        Returns:\n            float: Image direction information if available, otherwise None.\n        \"\"\"\n        if \"GPSImgDirection\" in geotags:\n            return geotags[\"GPSImgDirection\"]\n        return None\n\n    @classmethod\n    def _get_coordinates(cls, geotags):\n        \"\"\"\n        Retrieves the latitude and longitude coordinates from geotags.\n\n        Args:\n            geotags (dict): The geotags information.\n\n        Returns:\n            tuple: Latitude and longitude coordinates.\n\n        Raises:\n            ValueError: If the coordinates are invalid.\n        \"\"\"\n        lat = cls._to_decimal(geotags[\"GPSLatitude\"])\n        lon = cls._to_decimal(geotags[\"GPSLongitude\"])\n\n        if geotags[\"GPSLatitudeRef\"] == \"S\":\n            lat = -lat\n\n        if geotags[\"GPSLongitudeRef\"] == \"W\":\n            lon = -lon\n\n        return lat, lon\n\n    @staticmethod\n    def _get_focal_length(exif_data):\n        \"\"\"\n        Retrieves the focal length from the EXIF data.\n\n        Args:\n            exif_data (dict): The EXIF data.\n\n        Returns:\n            float: Focal length if available, otherwise None.\n        \"\"\"\n        focal_length = exif_data.get(\"FocalLength\", None)\n\n        if focal_length is None:\n            return None\n\n        if isinstance(focal_length, numbers.Number):\n            return float(focal_length)\n\n        elif (\n            isinstance(focal_length, tuple)\n            and len(focal_length) == 2\n            and focal_length[1] != 0\n        ):\n            return float(focal_length[0]) / focal_length[1]\n\n        elif (\n            hasattr(focal_length, \"num\")\n            and hasattr(focal_length, \"den\")\n            and focal_length.den != 0\n        ):\n            return float(focal_length.num) / focal_length.den\n\n        else:\n            return None\n\n    @classmethod\n    def load_images(cls, directory, additional_columns=None, create_thumbnails=True, thumbnail_size=(256, 256)):\n        \"\"\"\n        Loads images from a given directory, extracts relevant information, and returns it in a GeoImageFrame.\n\n        Args:\n            directory (str): Path to the directory containing images.\n            additional_columns (list, optional): List of additional column names or tuples containing column name and EXIF tag.\n            create_thumbnails (bool): Whether to create thumbnails for the images. Defaults to True.\n            thumbnail_size (tuple): Size for generated thumbnails as (width, height). Defaults to (256, 256).\n\n        Returns:\n            GeoImageFrame: Frame containing the data extracted from the images.\n\n        Raises:\n            ValueError: If no valid images are found in the directory.\n\n        Examples:\n            &gt;&gt;&gt; directory = \"/path/to/images\"\n            &gt;&gt;&gt; image_data = Local.load_images(directory, create_thumbnails=True)\n        \"\"\"\n        tf = TimezoneFinder()\n        data = []\n        valid_image_count = 0\n        for root, dirs, files in os.walk(directory):\n            # Skip thumbnails directory\n            if \"thumbnails\" in dirs:\n                dirs.remove(\"thumbnails\")\n            for file in files:\n                if file.lower().endswith((\".png\", \".jpg\", \".jpeg\")):\n                    valid_image_count += 1\n                    filepath = os.path.join(root, file)\n                    img = Image.open(filepath)\n                    exif_data = cls.get_exif_data(img)\n                    try:\n                        geotags = cls._get_geotagging(exif_data)\n                        lat, lon = cls._get_coordinates(geotags)\n                        if lat is None or lon is None:\n                            raise ValueError(\n                                f\"Invalid coordinates for {filepath}: Latitude: {lat}, Longitude: {lon}\"\n                            )\n                        geometry = Point(lon, lat)\n                    except Exception as e:\n                        warnings.warn(\n                            f\"Error extracting geotags for {filepath}: {str(e)}. Skipped.\"\n                        )\n                        continue\n                    focal_length = cls._get_focal_length(exif_data)\n                    camera_model = cls._get_camera_model(exif_data)\n                    camera_type = cls._infer_camera_type(focal_length, camera_model)\n\n                    k1 = None\n                    k2 = None\n                    if None in [focal_length, k1, k2]:\n                        camera_parameters = np.nan\n                    else:\n                        camera_parameters = \",\".join(\n                            [str(focal_length), str(k1), str(k2)]\n                        )\n\n                    captured_at_str = exif_data.get(\"DateTime\", None)\n                    if captured_at_str and geometry:\n                        captured_at_naive = datetime.strptime(\n                            captured_at_str, \"%Y:%m:%d %H:%M:%S\"\n                        )\n                        tz_name = tf.timezone_at(lat=lat, lng=lon)\n                        if tz_name:\n                            local_tz = pytz.timezone(tz_name)\n                            captured_at = local_tz.localize(\n                                captured_at_naive\n                            ).isoformat()\n                        else:\n                            captured_at = captured_at_naive.isoformat()\n                    else:\n                        captured_at = None\n\n                    altitude = np.float32(cls._get_image_altitude(geotags))\n                    compass_angle = np.float32(cls._get_image_direction(geotags))\n                    exif_orientation = np.float32(exif_data.get(\"Orientation\", None))\n\n                    # Generate thumbnail if requested\n                    thumb_url = None\n                    if create_thumbnails:\n                        try:\n                            # Check if thumbnail already exists\n                            thumbnail_dir = os.path.join(os.path.dirname(filepath), \"thumbnails\")\n                            thumb_filename = f\"thumb_{os.path.basename(filepath)}\"\n                            thumb_path = os.path.join(thumbnail_dir, thumb_filename)\n\n                            if os.path.exists(thumb_path):\n                                thumb_url = thumb_path\n                            else:\n                                thumb_url = cls.create_thumbnail(filepath, size=thumbnail_size)\n                        except Exception as e:\n                            warnings.warn(f\"Error creating thumbnail for {filepath}: {str(e)}\")\n\n                    image_data = {\n                        \"name\": filepath.split(\"/\")[-1],\n                        \"altitude\": altitude,\n                        \"camera_type\": camera_type,\n                        \"camera_parameters\": camera_parameters,\n                        \"captured_at\": captured_at,\n                        \"compass_angle\": compass_angle,\n                        \"exif_orientation\": exif_orientation,\n                        \"image_url\": filepath,\n                        \"thumb_url\": thumb_url,\n                        \"geometry\": geometry,\n                    }\n\n                    for column_info in additional_columns or []:\n                        if isinstance(column_info, str):\n                            image_data[column_info] = np.nan\n                        elif isinstance(column_info, tuple):\n                            col_name, exif_tag = column_info\n                            image_data[col_name] = exif_data.get(exif_tag, np.nan)\n\n                    data.append(image_data)\n\n        if valid_image_count == 0:\n            raise ValueError(\"The directory does not contain any valid images\")\n\n        gif = GeoImageFrame(data, geometry=\"geometry\")\n        gif.set_crs(epsg=4326, inplace=True)\n        return gif\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.image.Local._get_camera_model","title":"<code>_get_camera_model(exif_data)</code>  <code>staticmethod</code>","text":"<p>Extracts the camera model from the EXIF data.</p> <p>Parameters:</p> Name Type Description Default <code>exif_data</code> <code>dict</code> <p>The EXIF data.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Camera model if available, otherwise None.</p> Source code in <code>landlensdb/handlers/image.py</code> <pre><code>@staticmethod\ndef _get_camera_model(exif_data):\n    \"\"\"\n    Extracts the camera model from the EXIF data.\n\n    Args:\n        exif_data (dict): The EXIF data.\n\n    Returns:\n        str: Camera model if available, otherwise None.\n    \"\"\"\n    return exif_data.get(\"Model\", \"\").strip()\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.image.Local._get_coordinates","title":"<code>_get_coordinates(geotags)</code>  <code>classmethod</code>","text":"<p>Retrieves the latitude and longitude coordinates from geotags.</p> <p>Parameters:</p> Name Type Description Default <code>geotags</code> <code>dict</code> <p>The geotags information.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>Latitude and longitude coordinates.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the coordinates are invalid.</p> Source code in <code>landlensdb/handlers/image.py</code> <pre><code>@classmethod\ndef _get_coordinates(cls, geotags):\n    \"\"\"\n    Retrieves the latitude and longitude coordinates from geotags.\n\n    Args:\n        geotags (dict): The geotags information.\n\n    Returns:\n        tuple: Latitude and longitude coordinates.\n\n    Raises:\n        ValueError: If the coordinates are invalid.\n    \"\"\"\n    lat = cls._to_decimal(geotags[\"GPSLatitude\"])\n    lon = cls._to_decimal(geotags[\"GPSLongitude\"])\n\n    if geotags[\"GPSLatitudeRef\"] == \"S\":\n        lat = -lat\n\n    if geotags[\"GPSLongitudeRef\"] == \"W\":\n        lon = -lon\n\n    return lat, lon\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.image.Local._get_focal_length","title":"<code>_get_focal_length(exif_data)</code>  <code>staticmethod</code>","text":"<p>Retrieves the focal length from the EXIF data.</p> <p>Parameters:</p> Name Type Description Default <code>exif_data</code> <code>dict</code> <p>The EXIF data.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Focal length if available, otherwise None.</p> Source code in <code>landlensdb/handlers/image.py</code> <pre><code>@staticmethod\ndef _get_focal_length(exif_data):\n    \"\"\"\n    Retrieves the focal length from the EXIF data.\n\n    Args:\n        exif_data (dict): The EXIF data.\n\n    Returns:\n        float: Focal length if available, otherwise None.\n    \"\"\"\n    focal_length = exif_data.get(\"FocalLength\", None)\n\n    if focal_length is None:\n        return None\n\n    if isinstance(focal_length, numbers.Number):\n        return float(focal_length)\n\n    elif (\n        isinstance(focal_length, tuple)\n        and len(focal_length) == 2\n        and focal_length[1] != 0\n    ):\n        return float(focal_length[0]) / focal_length[1]\n\n    elif (\n        hasattr(focal_length, \"num\")\n        and hasattr(focal_length, \"den\")\n        and focal_length.den != 0\n    ):\n        return float(focal_length.num) / focal_length.den\n\n    else:\n        return None\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.image.Local._get_geotagging","title":"<code>_get_geotagging(exif)</code>  <code>classmethod</code>","text":"<p>Extracts geotagging information from EXIF metadata.</p> <p>Parameters:</p> Name Type Description Default <code>exif</code> <code>dict</code> <p>The EXIF metadata.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the geotagging information.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no EXIF metadata found or no GPSInfo tag found.</p> Source code in <code>landlensdb/handlers/image.py</code> <pre><code>@classmethod\ndef _get_geotagging(cls, exif):\n    \"\"\"\n    Extracts geotagging information from EXIF metadata.\n\n    Args:\n        exif (dict): The EXIF metadata.\n\n    Returns:\n        dict: A dictionary containing the geotagging information.\n\n    Raises:\n        ValueError: If no EXIF metadata found or no GPSInfo tag found.\n    \"\"\"\n    if not exif:\n        raise ValueError(\"No EXIF metadata found\")\n\n    idx = None\n    for tag, label in TAGS.items():\n        if label == \"GPSInfo\":\n            idx = tag\n            break\n\n    if idx is None:\n        raise ValueError(\"No GPSInfo tag found in TAGS.\")\n\n    gps_data = exif.get(\"GPSInfo\", exif.get(idx, None))\n    if not gps_data:\n        raise ValueError(\"No EXIF geotagging found\")\n\n    geotagging = {}\n    for key, val in GPSTAGS.items():\n        data_value = gps_data.get(key) or gps_data.get(val)\n        if data_value:\n            geotagging[val] = data_value\n\n    return geotagging\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.image.Local._get_image_altitude","title":"<code>_get_image_altitude(geotags)</code>  <code>classmethod</code>","text":"<p>Retrieves the altitude information from geotags.</p> <p>Parameters:</p> Name Type Description Default <code>geotags</code> <code>dict</code> <p>The geotags information.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Altitude information if available, otherwise None.</p> Source code in <code>landlensdb/handlers/image.py</code> <pre><code>@classmethod\ndef _get_image_altitude(cls, geotags):\n    \"\"\"\n    Retrieves the altitude information from geotags.\n\n    Args:\n        geotags (dict): The geotags information.\n\n    Returns:\n        float: Altitude information if available, otherwise None.\n    \"\"\"\n    if \"GPSAltitude\" in geotags:\n        return geotags[\"GPSAltitude\"]\n    return None\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.image.Local._get_image_direction","title":"<code>_get_image_direction(geotags)</code>  <code>classmethod</code>","text":"<p>Retrieves the image direction information from geotags.</p> <p>Parameters:</p> Name Type Description Default <code>geotags</code> <code>dict</code> <p>The geotags information.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Image direction information if available, otherwise None.</p> Source code in <code>landlensdb/handlers/image.py</code> <pre><code>@classmethod\ndef _get_image_direction(cls, geotags):\n    \"\"\"\n    Retrieves the image direction information from geotags.\n\n    Args:\n        geotags (dict): The geotags information.\n\n    Returns:\n        float: Image direction information if available, otherwise None.\n    \"\"\"\n    if \"GPSImgDirection\" in geotags:\n        return geotags[\"GPSImgDirection\"]\n    return None\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.image.Local._infer_camera_type","title":"<code>_infer_camera_type(focal_length, camera_model=None)</code>  <code>staticmethod</code>","text":"<p>Infers the camera type based on the focal length and camera model.</p> <p>Parameters:</p> Name Type Description Default <code>focal_length</code> <code>float</code> <p>The focal length of the camera.</p> required <code>camera_model</code> <code>str</code> <p>The camera model.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>One of \"fisheye\", \"perspective\", or \"360-degree\".</p> Source code in <code>landlensdb/handlers/image.py</code> <pre><code>@staticmethod\ndef _infer_camera_type(focal_length, camera_model=None):\n    \"\"\"\n    Infers the camera type based on the focal length and camera model.\n\n    Args:\n        focal_length (float): The focal length of the camera.\n        camera_model (str): The camera model.\n\n    Returns:\n        str: One of \"fisheye\", \"perspective\", or \"360-degree\".\n    \"\"\"\n    if not focal_length and not camera_model:\n        return np.nan\n\n    known_360_cameras = KNOWN_CAMERAS.get(\"360 Models\", [])\n\n    if camera_model in known_360_cameras:\n        return \"360-degree\"\n\n    # Further classification based on focal length\n    if focal_length &lt; 1.5:\n        return \"fisheye\"\n    else:\n        return \"perspective\"\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.image.Local._to_decimal","title":"<code>_to_decimal(coord_tuple)</code>  <code>staticmethod</code>","text":"<p>Converts coordinates from degrees, minutes, and seconds to decimal.</p> <p>Parameters:</p> Name Type Description Default <code>coord_tuple</code> <code>tuple or str</code> <p>The coordinate tuple to convert.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Decimal representation of the coordinates.</p> Source code in <code>landlensdb/handlers/image.py</code> <pre><code>@staticmethod\ndef _to_decimal(coord_tuple):\n    \"\"\"\n    Converts coordinates from degrees, minutes, and seconds to decimal.\n\n    Args:\n        coord_tuple (tuple or str): The coordinate tuple to convert.\n\n    Returns:\n        float: Decimal representation of the coordinates.\n    \"\"\"\n    if isinstance(coord_tuple, tuple) and len(coord_tuple) == 3:\n        return (\n            float(coord_tuple[0])\n            + float(coord_tuple[1]) / 60\n            + float(coord_tuple[2]) / 3600\n        )\n    elif isinstance(coord_tuple, str) and \"/\" in coord_tuple:\n        num, denom = coord_tuple.split(\"/\")\n        if float(denom) != 0:\n            return float(num) / float(denom)\n        else:\n            return None\n    return coord_tuple\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.image.Local.create_thumbnail","title":"<code>create_thumbnail(image_path, size=(256, 256))</code>  <code>staticmethod</code>","text":"<p>Creates a thumbnail for the given image while preserving aspect ratio.</p> <p>Parameters:</p> Name Type Description Default <code>image_path</code> <code>str</code> <p>Path to the original image</p> required <code>size</code> <code>tuple</code> <p>Desired thumbnail size as (width, height). Default is (256, 256)</p> <code>(256, 256)</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Path to the created thumbnail</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the image file doesn't exist</p> <code>ValueError</code> <p>If the image cannot be opened or processed</p> Source code in <code>landlensdb/handlers/image.py</code> <pre><code>@staticmethod\ndef create_thumbnail(image_path, size=(256, 256)):\n    \"\"\"\n    Creates a thumbnail for the given image while preserving aspect ratio.\n\n    Args:\n        image_path (str): Path to the original image\n        size (tuple): Desired thumbnail size as (width, height). Default is (256, 256)\n\n    Returns:\n        str: Path to the created thumbnail\n\n    Raises:\n        FileNotFoundError: If the image file doesn't exist\n        ValueError: If the image cannot be opened or processed\n    \"\"\"\n    if not os.path.exists(image_path):\n        raise FileNotFoundError(f\"Image file not found: {image_path}\")\n\n    # Create thumbnails directory in the same directory as the original image\n    original_dir = os.path.dirname(image_path)\n    thumbnail_dir = os.path.join(original_dir, \"thumbnails\")\n    os.makedirs(thumbnail_dir, exist_ok=True)\n\n    # Generate thumbnail filename\n    original_filename = os.path.basename(image_path)\n    thumbnail_filename = f\"thumb_{original_filename}\"\n    thumbnail_path = os.path.join(thumbnail_dir, thumbnail_filename)\n\n    try:\n        with Image.open(image_path) as img:\n            # Convert to RGB if necessary\n            if img.mode in ('RGBA', 'LA'):\n                img = img.convert('RGB')\n\n            # Calculate new dimensions preserving aspect ratio\n            img.thumbnail(size, Image.Resampling.LANCZOS)\n\n            # Save thumbnail\n            img.save(thumbnail_path, \"JPEG\", quality=85)\n            return thumbnail_path\n\n    except Exception as e:\n        raise ValueError(f\"Error creating thumbnail for {image_path}: {str(e)}\")\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.image.Local.get_exif_data","title":"<code>get_exif_data(img)</code>  <code>staticmethod</code>","text":"<p>Retrieves the EXIF data from an image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>Image</code> <p>The image to extract EXIF data from.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the EXIF data.</p> Source code in <code>landlensdb/handlers/image.py</code> <pre><code>@staticmethod\ndef get_exif_data(img):\n    \"\"\"\n    Retrieves the EXIF data from an image.\n\n    Args:\n        img (PIL.Image.Image): The image to extract EXIF data from.\n\n    Returns:\n        dict: A dictionary containing the EXIF data.\n    \"\"\"\n    exif_data = {}\n    info = img._getexif()\n    if info:\n        for tag, value in info.items():\n            tag_name = TAGS.get(tag, tag)\n            if tag_name == \"GPSInfo\":\n                gps_info = {}\n                for t in value:\n                    sub_tag_name = GPSTAGS.get(t, t)\n                    gps_info[sub_tag_name] = value[t]\n                exif_data[tag_name] = gps_info\n            else:\n                exif_data[tag_name] = value\n    return exif_data\n</code></pre>"},{"location":"api/handlers/#landlensdb.handlers.image.Local.load_images","title":"<code>load_images(directory, additional_columns=None, create_thumbnails=True, thumbnail_size=(256, 256))</code>  <code>classmethod</code>","text":"<p>Loads images from a given directory, extracts relevant information, and returns it in a GeoImageFrame.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>Path to the directory containing images.</p> required <code>additional_columns</code> <code>list</code> <p>List of additional column names or tuples containing column name and EXIF tag.</p> <code>None</code> <code>create_thumbnails</code> <code>bool</code> <p>Whether to create thumbnails for the images. Defaults to True.</p> <code>True</code> <code>thumbnail_size</code> <code>tuple</code> <p>Size for generated thumbnails as (width, height). Defaults to (256, 256).</p> <code>(256, 256)</code> <p>Returns:</p> Name Type Description <code>GeoImageFrame</code> <p>Frame containing the data extracted from the images.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no valid images are found in the directory.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; directory = \"/path/to/images\"\n&gt;&gt;&gt; image_data = Local.load_images(directory, create_thumbnails=True)\n</code></pre> Source code in <code>landlensdb/handlers/image.py</code> <pre><code>@classmethod\ndef load_images(cls, directory, additional_columns=None, create_thumbnails=True, thumbnail_size=(256, 256)):\n    \"\"\"\n    Loads images from a given directory, extracts relevant information, and returns it in a GeoImageFrame.\n\n    Args:\n        directory (str): Path to the directory containing images.\n        additional_columns (list, optional): List of additional column names or tuples containing column name and EXIF tag.\n        create_thumbnails (bool): Whether to create thumbnails for the images. Defaults to True.\n        thumbnail_size (tuple): Size for generated thumbnails as (width, height). Defaults to (256, 256).\n\n    Returns:\n        GeoImageFrame: Frame containing the data extracted from the images.\n\n    Raises:\n        ValueError: If no valid images are found in the directory.\n\n    Examples:\n        &gt;&gt;&gt; directory = \"/path/to/images\"\n        &gt;&gt;&gt; image_data = Local.load_images(directory, create_thumbnails=True)\n    \"\"\"\n    tf = TimezoneFinder()\n    data = []\n    valid_image_count = 0\n    for root, dirs, files in os.walk(directory):\n        # Skip thumbnails directory\n        if \"thumbnails\" in dirs:\n            dirs.remove(\"thumbnails\")\n        for file in files:\n            if file.lower().endswith((\".png\", \".jpg\", \".jpeg\")):\n                valid_image_count += 1\n                filepath = os.path.join(root, file)\n                img = Image.open(filepath)\n                exif_data = cls.get_exif_data(img)\n                try:\n                    geotags = cls._get_geotagging(exif_data)\n                    lat, lon = cls._get_coordinates(geotags)\n                    if lat is None or lon is None:\n                        raise ValueError(\n                            f\"Invalid coordinates for {filepath}: Latitude: {lat}, Longitude: {lon}\"\n                        )\n                    geometry = Point(lon, lat)\n                except Exception as e:\n                    warnings.warn(\n                        f\"Error extracting geotags for {filepath}: {str(e)}. Skipped.\"\n                    )\n                    continue\n                focal_length = cls._get_focal_length(exif_data)\n                camera_model = cls._get_camera_model(exif_data)\n                camera_type = cls._infer_camera_type(focal_length, camera_model)\n\n                k1 = None\n                k2 = None\n                if None in [focal_length, k1, k2]:\n                    camera_parameters = np.nan\n                else:\n                    camera_parameters = \",\".join(\n                        [str(focal_length), str(k1), str(k2)]\n                    )\n\n                captured_at_str = exif_data.get(\"DateTime\", None)\n                if captured_at_str and geometry:\n                    captured_at_naive = datetime.strptime(\n                        captured_at_str, \"%Y:%m:%d %H:%M:%S\"\n                    )\n                    tz_name = tf.timezone_at(lat=lat, lng=lon)\n                    if tz_name:\n                        local_tz = pytz.timezone(tz_name)\n                        captured_at = local_tz.localize(\n                            captured_at_naive\n                        ).isoformat()\n                    else:\n                        captured_at = captured_at_naive.isoformat()\n                else:\n                    captured_at = None\n\n                altitude = np.float32(cls._get_image_altitude(geotags))\n                compass_angle = np.float32(cls._get_image_direction(geotags))\n                exif_orientation = np.float32(exif_data.get(\"Orientation\", None))\n\n                # Generate thumbnail if requested\n                thumb_url = None\n                if create_thumbnails:\n                    try:\n                        # Check if thumbnail already exists\n                        thumbnail_dir = os.path.join(os.path.dirname(filepath), \"thumbnails\")\n                        thumb_filename = f\"thumb_{os.path.basename(filepath)}\"\n                        thumb_path = os.path.join(thumbnail_dir, thumb_filename)\n\n                        if os.path.exists(thumb_path):\n                            thumb_url = thumb_path\n                        else:\n                            thumb_url = cls.create_thumbnail(filepath, size=thumbnail_size)\n                    except Exception as e:\n                        warnings.warn(f\"Error creating thumbnail for {filepath}: {str(e)}\")\n\n                image_data = {\n                    \"name\": filepath.split(\"/\")[-1],\n                    \"altitude\": altitude,\n                    \"camera_type\": camera_type,\n                    \"camera_parameters\": camera_parameters,\n                    \"captured_at\": captured_at,\n                    \"compass_angle\": compass_angle,\n                    \"exif_orientation\": exif_orientation,\n                    \"image_url\": filepath,\n                    \"thumb_url\": thumb_url,\n                    \"geometry\": geometry,\n                }\n\n                for column_info in additional_columns or []:\n                    if isinstance(column_info, str):\n                        image_data[column_info] = np.nan\n                    elif isinstance(column_info, tuple):\n                        col_name, exif_tag = column_info\n                        image_data[col_name] = exif_data.get(exif_tag, np.nan)\n\n                data.append(image_data)\n\n    if valid_image_count == 0:\n        raise ValueError(\"The directory does not contain any valid images\")\n\n    gif = GeoImageFrame(data, geometry=\"geometry\")\n    gif.set_crs(epsg=4326, inplace=True)\n    return gif\n</code></pre>"},{"location":"api/process/","title":"Process API","text":""},{"location":"api/process/#road-network","title":"Road Network","text":""},{"location":"api/process/#landlensdb.process.road_network.clear_network_cache","title":"<code>clear_network_cache(cache_dir=None, older_than_days=None)</code>","text":"<p>Clear cached road networks.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>str</code> <p>Cache directory to clear. If None, uses default.</p> <code>None</code> <code>older_than_days</code> <code>int</code> <p>Only clear networks older than this many days.</p> <code>None</code> Source code in <code>landlensdb/process/road_network.py</code> <pre><code>def clear_network_cache(cache_dir=None, older_than_days=None):\n    \"\"\"Clear cached road networks.\n\n    Args:\n        cache_dir (str, optional): Cache directory to clear. If None, uses default.\n        older_than_days (int, optional): Only clear networks older than this many days.\n    \"\"\"\n    if cache_dir is None:\n        cache_dir = create_network_cache_dir()\n\n    if not os.path.exists(cache_dir):\n        return\n\n    for filename in os.listdir(cache_dir):\n        if not filename.endswith('.gpkg'):\n            continue\n\n        filepath = os.path.join(cache_dir, filename)\n        if older_than_days is not None:\n            file_age = (datetime.now() - datetime.fromtimestamp(os.path.getmtime(filepath))).days\n            if file_age &lt;= older_than_days:\n                continue\n\n        try:\n            os.remove(filepath)\n        except Exception as e:\n            warnings.warn(f\"Failed to remove cached network {filename}: {str(e)}\")\n</code></pre>"},{"location":"api/process/#landlensdb.process.road_network.create_network_cache_dir","title":"<code>create_network_cache_dir()</code>","text":"<p>Create a cache directory for storing downloaded road networks.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Path to the cache directory</p> Source code in <code>landlensdb/process/road_network.py</code> <pre><code>def create_network_cache_dir():\n    \"\"\"Create a cache directory for storing downloaded road networks.\n\n    Returns:\n        str: Path to the cache directory\n    \"\"\"\n    cache_dir = os.path.join(os.path.expanduser(\"~\"), \".landlensdb\", \"network_cache\")\n    os.makedirs(cache_dir, exist_ok=True)\n    return cache_dir\n</code></pre>"},{"location":"api/process/#landlensdb.process.road_network.get_osm_lines","title":"<code>get_osm_lines(bbox, network_type='drive', cache_dir=None, retries=3)</code>","text":"<p>Get road network from OpenStreetMap for a given bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list</code> <p>Bounding box coordinates [minx, miny, maxx, maxy]. Can be in any CRS.</p> required <code>network_type</code> <code>str</code> <p>Type of network to fetch. Defaults to 'drive' Options are: {\"all\", \"all_public\", \"bike\", \"drive\", \"drive_service\", \"walk\"}.</p> <code>'drive'</code> <code>cache_dir</code> <code>str</code> <p>Directory to cache downloaded networks. Defaults to None.</p> <code>None</code> <code>retries</code> <code>int</code> <p>Number of times to retry fetching network. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>GeoDataFrame</code> <p>Road network as a GeoDataFrame.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If network cannot be fetched after retries.</p> <code>ValueError</code> <p>If bbox coordinates are invalid.</p> Source code in <code>landlensdb/process/road_network.py</code> <pre><code>def get_osm_lines(bbox, network_type='drive', cache_dir=None, retries=3):\n    \"\"\"Get road network from OpenStreetMap for a given bounding box.\n\n    Args:\n        bbox (list): Bounding box coordinates [minx, miny, maxx, maxy].\n            Can be in any CRS.\n        network_type (str, optional): Type of network to fetch.\n            Defaults to 'drive' Options are: {\"all\", \"all_public\", \"bike\", \"drive\", \"drive_service\", \"walk\"}.\n        cache_dir (str, optional): Directory to cache downloaded networks.\n            Defaults to None.\n        retries (int, optional): Number of times to retry fetching network.\n            Defaults to 3.\n\n    Returns:\n        GeoDataFrame: Road network as a GeoDataFrame.\n\n    Raises:\n        ConnectionError: If network cannot be fetched after retries.\n        ValueError: If bbox coordinates are invalid.\n    \"\"\"\n    # Input validation\n    if len(bbox) != 4:\n        raise ValueError(\"bbox must contain exactly 4 coordinates\")\n\n    # Convert bbox to GeoDataFrame to handle CRS conversion\n    bbox_geom = box(bbox[0], bbox[1], bbox[2], bbox[3])\n    bbox_gdf = gpd.GeoDataFrame(geometry=[bbox_geom], crs=\"EPSG:4326\")\n\n    # Get bounds in WGS84\n    bbox_wgs84 = bbox_gdf.geometry.total_bounds\n\n    # Validate coordinates are within valid ranges\n    if (bbox_wgs84[0] &lt; -180 or bbox_wgs84[2] &gt; 180 or\n        bbox_wgs84[1] &lt; -90 or bbox_wgs84[3] &gt; 90):\n        raise ValueError(\n            \"Invalid coordinates. Longitude must be between -180 and 180, \"\n            \"latitude between -90 and 90\"\n        )\n\n    # Create bbox tuple for OSMnx (left, bottom, right, top)\n    west, south = min(bbox_wgs84[0], bbox_wgs84[2]), min(bbox_wgs84[1], bbox_wgs84[3])\n    east, north = max(bbox_wgs84[0], bbox_wgs84[2]), max(bbox_wgs84[1], bbox_wgs84[3])\n    bbox_tuple = (west, south, east, north)\n\n    # Set up cache directory\n    if cache_dir:\n        os.makedirs(cache_dir, exist_ok=True)\n        ox.settings.cache_folder = cache_dir\n\n    # Try to fetch network with retries\n    for attempt in range(retries):\n        try:\n            # Pass bbox as a tuple\n            graph = ox.graph_from_bbox(\n                bbox=bbox_tuple,\n                network_type=network_type,\n                truncate_by_edge=True\n            )\n            network = ox.graph_to_gdfs(graph, nodes=False)\n            return network\n        except Exception as e:\n            if attempt == retries - 1:\n                msg = (\n                    f\"Failed to fetch OSM network after {retries} attempts: {str(e)}\"\n                )\n                raise ConnectionError(msg)\n            print(f\"Attempt {attempt + 1} failed, retrying in 1 second...\")\n            time.sleep(1)\n\n    return None\n</code></pre>"},{"location":"api/process/#landlensdb.process.road_network.optimize_network_for_snapping","title":"<code>optimize_network_for_snapping(network, simplify=True, remove_isolated=True)</code>","text":"<p>Optimize road network for efficient snapping operations.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>GeoDataFrame</code> <p>The road network to optimize</p> required <code>simplify</code> <code>bool</code> <p>Whether to simplify geometries</p> <code>True</code> <code>remove_isolated</code> <code>bool</code> <p>Whether to remove isolated segments</p> <code>True</code> <p>Returns:</p> Name Type Description <code>GeoDataFrame</code> <p>Optimized network</p> Source code in <code>landlensdb/process/road_network.py</code> <pre><code>def optimize_network_for_snapping(network, simplify=True, remove_isolated=True):\n    \"\"\"Optimize road network for efficient snapping operations.\n\n    Args:\n        network (GeoDataFrame): The road network to optimize\n        simplify (bool): Whether to simplify geometries\n        remove_isolated (bool): Whether to remove isolated segments\n\n    Returns:\n        GeoDataFrame: Optimized network\n    \"\"\"\n    if network is None or network.empty:\n        return network\n\n    # Work on a copy\n    network = network.copy()\n\n    # Ensure proper CRS\n    if network.crs is None:\n        network.set_crs(epsg=4326, inplace=True)\n\n    # Simplify geometries while preserving topology\n    if simplify:\n        network.geometry = network.geometry.simplify(tolerance=1e-5)\n\n    # Remove duplicate geometries\n    network = network.drop_duplicates(subset='geometry')\n\n    # Remove isolated segments if requested\n    if remove_isolated:\n        # Find connected components\n        G = nx.Graph()\n        for idx, row in network.iterrows():\n            coords = list(row.geometry.coords)\n            for i in range(len(coords)-1):\n                G.add_edge(coords[i], coords[i+1])\n\n        # Keep only largest component\n        largest_cc = max(nx.connected_components(G), key=len)\n        network = network[network.geometry.apply(\n            lambda g: any(c in largest_cc for c in g.coords)\n        )]\n\n    # Create spatial index\n    network.sindex\n\n    return network\n</code></pre>"},{"location":"api/process/#landlensdb.process.road_network.validate_network_topology","title":"<code>validate_network_topology(network)</code>","text":"<p>Validate and repair road network topology.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>GeoDataFrame</code> <p>Road network to validate</p> required <p>Returns:</p> Name Type Description <code>GeoDataFrame</code> <p>Validated and repaired network</p> <code>dict</code> <p>Report of validation results</p> Source code in <code>landlensdb/process/road_network.py</code> <pre><code>def validate_network_topology(network):\n    \"\"\"Validate and repair road network topology.\n\n    Args:\n        network (GeoDataFrame): Road network to validate\n\n    Returns:\n        GeoDataFrame: Validated and repaired network\n        dict: Report of validation results\n    \"\"\"\n    if network is None or network.empty:\n        return network, {'status': 'empty'}\n\n    report = {\n        'original_size': len(network),\n        'issues': [],\n        'repairs': []\n    }\n\n    # Check for invalid geometries\n    invalid_mask = ~network.geometry.is_valid\n    if invalid_mask.any():\n        report['issues'].append(f\"Found {invalid_mask.sum()} invalid geometries\")\n        network.geometry = network.geometry.buffer(0)\n        report['repairs'].append(\"Applied buffer(0) to fix invalid geometries\")\n\n    # Check for duplicate geometries\n    duplicates = network.geometry.duplicated()\n    if duplicates.any():\n        report['issues'].append(f\"Found {duplicates.sum()} duplicate geometries\")\n        network = network[~duplicates]\n        report['repairs'].append(\"Removed duplicate geometries\")\n\n    # Check for null geometries\n    null_geoms = network.geometry.isna()\n    if null_geoms.any():\n        report['issues'].append(f\"Found {null_geoms.sum()} null geometries\")\n        network = network[~null_geoms]\n        report['repairs'].append(\"Removed null geometries\")\n\n    # Check connectivity\n    G = nx.Graph()\n    for idx, row in network.iterrows():\n        coords = list(row.geometry.coords)\n        for i in range(len(coords)-1):\n            G.add_edge(coords[i], coords[i+1])\n\n    components = list(nx.connected_components(G))\n    if len(components) &gt; 1:\n        report['issues'].append(f\"Found {len(components)} disconnected components\")\n        report['repairs'].append(\"Consider using optimize_network_for_snapping() to clean\")\n\n    report['final_size'] = len(network)\n    return network, report\n</code></pre>"},{"location":"api/process/#snap","title":"Snap","text":""},{"location":"api/process/#landlensdb.process.snap._calculate_bearing","title":"<code>_calculate_bearing(point1, point2)</code>","text":"<p>Calculate the bearing between two points.</p> <p>Parameters:</p> Name Type Description Default <code>point1</code> <code>Point</code> <p>Starting point.</p> required <code>point2</code> <code>Point</code> <p>Ending point.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The bearing in degrees.</p> Source code in <code>landlensdb/process/snap.py</code> <pre><code>def _calculate_bearing(point1, point2):\n    \"\"\"Calculate the bearing between two points.\n\n    Args:\n        point1 (shapely.geometry.Point): Starting point.\n        point2 (shapely.geometry.Point): Ending point.\n\n    Returns:\n        float: The bearing in degrees.\n    \"\"\"\n    lon1, lat1 = math.radians(point1.x), math.radians(point1.y)\n    lon2, lat2 = math.radians(point2.x), math.radians(point2.y)\n    dlon = lon2 - lon1\n    x = math.atan2(\n        math.sin(dlon) * math.cos(lat2),\n        math.cos(lat1) * math.sin(lat2)\n        - math.sin(lat1) * math.cos(lat2) * math.cos(dlon),\n    )\n    bearing = (math.degrees(x) + 360) % 360\n    return bearing\n</code></pre>"},{"location":"api/process/#landlensdb.process.snap._create_spatial_index","title":"<code>_create_spatial_index(network)</code>","text":"<p>Create a spatial index for the given network using Rtree.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing the network lines.</p> required <p>Returns:</p> Type Description <p>rtree.index.Index: A spatial index for efficient spatial querying.</p> Source code in <code>landlensdb/process/snap.py</code> <pre><code>def _create_spatial_index(network):\n    \"\"\"Create a spatial index for the given network using Rtree.\n\n    Args:\n        network (GeoDataFrame): A GeoDataFrame containing the network lines.\n\n    Returns:\n        rtree.index.Index: A spatial index for efficient spatial querying.\n    \"\"\"\n    idx = index.Index()\n    for i, line in enumerate(network):\n        idx.insert(i, line.bounds)\n    return idx\n</code></pre>"},{"location":"api/process/#landlensdb.process.snap._get_nearest_segment","title":"<code>_get_nearest_segment(point, network, idx)</code>","text":"<p>Find the nearest segment to a given point in a spatially indexed network.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>The point to find the nearest segment to.</p> required <code>network</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing the network lines.</p> required <code>idx</code> <code>Index</code> <p>The spatial index of the network.</p> required <p>Returns:</p> Type Description <p>shapely.geometry.LineString: The nearest line segment to the point.</p> Source code in <code>landlensdb/process/snap.py</code> <pre><code>def _get_nearest_segment(point, network, idx):\n    \"\"\"Find the nearest segment to a given point in a spatially indexed network.\n\n    Args:\n        point (shapely.geometry.Point): The point to find the nearest segment to.\n        network (GeoDataFrame): A GeoDataFrame containing the network lines.\n        idx (rtree.index.Index): The spatial index of the network.\n\n    Returns:\n        shapely.geometry.LineString: The nearest line segment to the point.\n    \"\"\"\n    nearest_lines = list(idx.nearest(point.bounds, 1))\n    nearest = min(\n        [\n            (line, point.distance(line))\n            for line in [network.iloc[i] for i in nearest_lines]\n        ],\n        key=lambda x: x[1],\n    )[0]\n    return nearest\n</code></pre>"},{"location":"api/process/#landlensdb.process.snap.align_compass_with_road","title":"<code>align_compass_with_road(points, network)</code>","text":"<p>Aligns the compass angle of points with the bearing of the nearest road segment.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing points with compass angles.</p> required <code>network</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing the road network.</p> required <p>Returns:</p> Name Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame with updated snapped_angle field.</p> Source code in <code>landlensdb/process/snap.py</code> <pre><code>def align_compass_with_road(points, network):\n    \"\"\"Aligns the compass angle of points with the bearing of the nearest road segment.\n\n    Args:\n        points (GeoDataFrame): A GeoDataFrame containing points with compass angles.\n        network (GeoDataFrame): A GeoDataFrame containing the road network.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame with updated snapped_angle field.\n    \"\"\"\n    if points[\"snapped_geometry\"].isnull().any():\n        warnings.warn(\n            \"\"\"\n            GeodataImageFrame contains rows with empty snapped_geometry. Non-snapped images will be skipped.\n            To snap all images, try increasing the threshold or changing the road network.\n            \"\"\"\n        )\n    idx = _create_spatial_index(network.geometry)\n    for row_idx, point in points.iterrows():\n        if point.snapped_geometry is None:\n            continue\n        nearest_segment = _get_nearest_segment(\n            point.snapped_geometry, network.geometry, idx\n        )\n        segment_coords = nearest_segment.coords[:]\n        segment_bearing = _calculate_bearing(\n            Point(segment_coords[0]), Point(segment_coords[1])\n        )\n\n        difference_0 = abs(segment_bearing - point.compass_angle)\n        difference_180 = abs((segment_bearing + 180) % 360 - point.compass_angle)\n\n        if difference_0 &lt; difference_180:\n            points.at[row_idx, \"snapped_angle\"] = segment_bearing\n        else:\n            points.at[row_idx, \"snapped_angle\"] = (segment_bearing + 180) % 360\n    return points\n</code></pre>"},{"location":"api/process/#landlensdb.process.snap.create_bbox","title":"<code>create_bbox(point, x_distance_meters, y_distance_meters)</code>","text":"<p>Create a bounding box around a point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point</code> <p>The center point for the bounding box.</p> required <code>x_distance_meters</code> <code>float</code> <p>The horizontal distance in meters.</p> required <code>y_distance_meters</code> <code>float</code> <p>The vertical distance in meters.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Bounding box coordinates [minx, miny, maxx, maxy] in EPSG:4326.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input is not a Shapely Point.</p> Source code in <code>landlensdb/process/snap.py</code> <pre><code>def create_bbox(point, x_distance_meters, y_distance_meters):\n    \"\"\"Create a bounding box around a point.\n\n    Args:\n        point (shapely.geometry.Point): The center point for the bounding box.\n        x_distance_meters (float): The horizontal distance in meters.\n        y_distance_meters (float): The vertical distance in meters.\n\n    Returns:\n        list: Bounding box coordinates [minx, miny, maxx, maxy] in EPSG:4326.\n\n    Raises:\n        ValueError: If the input is not a Shapely Point.\n    \"\"\"\n    if not isinstance(point, Point):\n        raise ValueError(\"Input must be a Shapely Point.\")\n\n    geoseries = gpd.GeoSeries([point], crs=\"EPSG:4326\")\n    point_mercator = geoseries.to_crs(\"EPSG:3857\").iloc[0]\n\n    minx = point_mercator.x - x_distance_meters / 2\n    maxx = point_mercator.x + x_distance_meters / 2\n    miny = point_mercator.y - y_distance_meters / 2\n    maxy = point_mercator.y + y_distance_meters / 2\n\n    bbox_geoseries = gpd.GeoSeries(\n        [Point(coord) for coord in [(minx, miny), (maxx, maxy)]], crs=\"EPSG:3857\"\n    )\n    transformed_coords = bbox_geoseries.to_crs(\"EPSG:4326\").tolist()\n\n    bbox = [\n        transformed_coords[0].x,\n        transformed_coords[0].y,\n        transformed_coords[1].x,\n        transformed_coords[1].y,\n    ]\n\n    return bbox\n</code></pre>"},{"location":"api/process/#landlensdb.process.snap.snap_to_road_network","title":"<code>snap_to_road_network(gif, tolerance, network=None, bbox=None, network_type='all_private', realign_camera=True, cache_dir=None)</code>","text":"<p>Enhanced function to snap points to road network with automatic network fetching.</p> <p>Parameters:</p> Name Type Description Default <code>gif</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing images and their geometries</p> required <code>tolerance</code> <code>float</code> <p>The snapping distance in meters</p> required <code>network</code> <code>GeoDataFrame</code> <p>Existing road network to use</p> <code>None</code> <code>bbox</code> <code>list</code> <p>Bounding box to fetch network for if none provided</p> <code>None</code> <code>network_type</code> <code>str</code> <p>Type of network to fetch</p> <code>'all_private'</code> <code>realign_camera</code> <code>bool</code> <p>Whether to realign camera angles</p> <code>True</code> <code>cache_dir</code> <code>str</code> <p>Directory to cache downloaded networks</p> <code>None</code> <p>Returns:</p> Name Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame with updated snapped geometries</p> Source code in <code>landlensdb/process/snap.py</code> <pre><code>def snap_to_road_network(gif, tolerance, network=None, bbox=None, network_type=\"all_private\", \n                        realign_camera=True, cache_dir=None):\n    \"\"\"Enhanced function to snap points to road network with automatic network fetching.\n\n    Args:\n        gif (GeoDataFrame): A GeoDataFrame containing images and their geometries\n        tolerance (float): The snapping distance in meters\n        network (GeoDataFrame, optional): Existing road network to use\n        bbox (list, optional): Bounding box to fetch network for if none provided\n        network_type (str, optional): Type of network to fetch\n        realign_camera (bool, optional): Whether to realign camera angles\n        cache_dir (str, optional): Directory to cache downloaded networks\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame with updated snapped geometries\n    \"\"\"\n    if network is None and bbox is None:\n        bbox = gif.geometry.total_bounds\n\n    if network is None:\n        if cache_dir is None:\n            cache_dir = create_network_cache_dir()\n        network = get_osm_lines(bbox, network_type=network_type, cache_dir=cache_dir)\n\n    # Optimize network for snapping\n    network = optimize_network_for_snapping(network)\n\n    # Validate network topology\n    network, report = validate_network_topology(network)\n    if report['issues']:\n        warnings.warn(f\"Network validation found issues: {report['issues']}\")\n\n    points = gif[[\"image_url\", \"geometry\"]].copy()\n    points = points.to_crs(3857)\n\n    if network is None:\n        raise Exception(\n            \"Network is missing. Please supply road network or set use_osm to True\"\n        )\n    if \"LineString\" not in network.geom_type.values:\n        raise Exception(\n            \"Invalid geometry. Network geodataframe geometry must contain LineString geometries\"\n        )\n\n    lines = network.to_crs(3857)\n\n    bbox_series = points.bounds + [-tolerance, -tolerance, tolerance, tolerance]\n    hits = bbox_series.apply(lambda row: list(lines.sindex.intersection(row)), axis=1)\n\n    tmp = pd.DataFrame(\n        {\n            \"pt_idx\": np.repeat(hits.index, hits.apply(len)),\n            \"line_i\": np.concatenate(hits.values),\n        }\n    )\n    tmp = tmp.join(lines.reset_index(drop=True), on=\"line_i\")\n    tmp = tmp.join(points.geometry.rename(\"point\"), on=\"pt_idx\")\n    tmp = gpd.GeoDataFrame(tmp, geometry=\"geometry\", crs=points.crs)\n\n    tmp[\"snap_dist\"] = tmp.geometry.distance(gpd.GeoSeries(tmp.point))\n    tmp = tmp.loc[tmp.snap_dist &lt;= tolerance]\n    tmp = tmp.sort_values(by=[\"snap_dist\"])\n\n    closest = tmp.groupby(\"pt_idx\").first()\n    closest = gpd.GeoDataFrame(closest, geometry=\"geometry\")\n\n    pos = closest.geometry.project(gpd.GeoSeries(closest.point))\n    new_pts = closest.geometry.interpolate(pos)\n\n    new_pts.crs = \"EPSG:3857\"\n    new_pts = new_pts.to_crs(4326)\n    gif[\"snapped_geometry\"] = new_pts.geometry\n\n    missing = gif[gif[\"snapped_geometry\"].isnull()].image_url.tolist()\n    if len(missing) &gt; 0:\n        warnings.warn(\n            f\"\"\"\n        Not all images were snapped. Non-snapped images will not be added \n        to the snapped image table. To snap all images, try increasing the threshold \n        or changing the road network. The following images could not be snapped \n        to a road network: {missing}\n        \"\"\"\n        )\n\n    if realign_camera:\n        if \"compass_angle\" not in gif.columns:\n            warnings.warn(\n                f\"realign_camera requires the compass_angle field. Cannot calculate snapped camera angle.\"\n            )\n        else:\n            if \"snapped_angle\" not in gif.columns:\n                gif[\"snapped_angle\"] = np.nan\n            gif = align_compass_with_road(gif, network)\n\n    return gif\n</code></pre>"},{"location":"examples/getting-started/","title":"Getting started","text":"In\u00a0[\u00a0]: Copied! <pre>import os\nimport geopandas as gpd\n\nfrom landlensdb.handlers.image import Local\nfrom landlensdb.process.snap import snap_to_road_network\nfrom landlensdb.handlers.db import Postgres\nfrom landlensdb.geoclasses.geoimageframe import GeoImageFrame\n</pre> import os import geopandas as gpd  from landlensdb.handlers.image import Local from landlensdb.process.snap import snap_to_road_network from landlensdb.handlers.db import Postgres from landlensdb.geoclasses.geoimageframe import GeoImageFrame In\u00a0[\u00a0]: Copied! <pre>relative_path = \"../example_data/360_images\"\nabsolute_path = os.path.abspath(relative_path)\n\nimages = Local.load_images(absolute_path, create_thumbnails=False)\nimages.head()\n</pre> relative_path = \"../example_data/360_images\" absolute_path = os.path.abspath(relative_path)  images = Local.load_images(absolute_path, create_thumbnails=False) images.head() <p>The resulting image is a GeoImageFrame, which is a simple extension of a Pandas GeoDataFrame with a few required column definitions and additional methods for visualization and data verification.</p> In\u00a0[\u00a0]: Copied! <pre>network = gpd.read_file('../example_data/trail.geojson')\n</pre> network = gpd.read_file('../example_data/trail.geojson') <p>Then, calling the <code>snap_to_road_network</code> will snap all points to the closest road network (within the provided threshold distance) and will create a new geometry column in the <code>GeoImageFrame</code> falled <code>snapped_geometry</code> to represent this new point.</p> In\u00a0[\u00a0]: Copied! <pre>snap_to_road_network(images, 100, network, realign_camera=True).head()\n</pre> snap_to_road_network(images, 100, network, realign_camera=True).head() In\u00a0[\u00a0]: Copied! <pre>images.map(\n    additional_properties=['altitude', 'camera_type'],\n    additional_geometries=[\n        {'geometry': 'snapped_geometry', 'angle': 'snapped_angle', 'label': 'Snapped'},\n    ]\n)\n</pre> images.map(     additional_properties=['altitude', 'camera_type'],     additional_geometries=[         {'geometry': 'snapped_geometry', 'angle': 'snapped_angle', 'label': 'Snapped'},     ] ) In\u00a0[\u00a0]: Copied! <pre>images.to_file('./images_tutorial.gpkg')\n</pre> images.to_file('./images_tutorial.gpkg') <p>However, in the current version when reading a saved vector format it is important to then initialize the GeoDataFrame as a GeoImageFrame if you want to make use of the features of <code>landlensdb</code>. For example:</p> In\u00a0[\u00a0]: Copied! <pre>images_gdf = gpd.read_file('./images_tutorial.gpkg')\nimages = GeoImageFrame(images_gdf)\n</pre> images_gdf = gpd.read_file('./images_tutorial.gpkg') images = GeoImageFrame(images_gdf) In\u00a0[\u00a0]: Copied! <pre>db_con = Postgres(\"postgresql://localhost:5432/landlens\")\n</pre> db_con = Postgres(\"postgresql://localhost:5432/landlens\") <p>This database must already exist and have PostGIS loaded.</p> <p>Then, you can save using <code>to_postgis</code>:</p> In\u00a0[\u00a0]: Copied! <pre>images.to_postgis(\"tutorial\", db_con.engine, if_exists=\"replace\")\n</pre> images.to_postgis(\"tutorial\", db_con.engine, if_exists=\"replace\") In\u00a0[\u00a0]: Copied! <pre>db_con.upsert_images(images, \"tutorial\", conflict='update')\n</pre> db_con.upsert_images(images, \"tutorial\", conflict='update') In\u00a0[\u00a0]: Copied! <pre>high_altitude_images = db_con.table(\"tutorial\").filter(altitude__gt=170).all()\n\nhigh_altitude_images.map(\n    additional_properties=['altitude', 'camera_type']\n)\n</pre> high_altitude_images = db_con.table(\"tutorial\").filter(altitude__gt=170).all()  high_altitude_images.map(     additional_properties=['altitude', 'camera_type'] ) <p>Finally, you can save the map as an html file if you like:</p> In\u00a0[\u00a0]: Copied! <pre>high_alt_map = high_altitude_images.map(\n    additional_properties=['altitude', 'camera_type']\n)\n\nhigh_alt_map.save('./high_alt_map.html')\n</pre> high_alt_map = high_altitude_images.map(     additional_properties=['altitude', 'camera_type'] )  high_alt_map.save('./high_alt_map.html')"},{"location":"examples/getting-started/#getting-started-loading-processing-visualizing-and-storing-data","title":"Getting Started: Loading, Processing, Visualizing, and Storing Data\u00b6","text":"<p>This short notebook demostrates how you can get started with <code>landlensdb</code> can be used to load, process, visualize, and store street-view data from local file directories.</p>"},{"location":"examples/getting-started/#pre-requisites","title":"Pre-requisites\u00b6","text":"<p>Before getting started, you will need to have PostgreSQL and PostGIS installed.</p>"},{"location":"examples/getting-started/#postgresql-and-postgis","title":"PostgreSQL and PostGIS\u00b6","text":"<p>Once PostgreSQL and PostGIS are installed, or if they are already installed, then you will need to have a PostGIS enabled PostgreSQL database to work with. To create one, use:</p> <pre>createdb &lt;database_name&gt; &amp;&amp; psql &lt;database_name&gt; -c \"CREATE EXTENSION POSTGIS\"\n</pre> <p>Be sure to replace <code>&lt;database_name&gt;</code> with the name you want to call your database. For example, it could be:</p> <pre>createdb landlens &amp;&amp; psql landlens -c \"CREATE EXTENSION POSTGIS\"\n</pre> <p>Once this is done, you should be ready to proceed with the tutorial.</p> <p>If you don't have <code>landlensdb</code> installed, you can do so with <code>pip install landlensdb</code>.</p>"},{"location":"examples/getting-started/#1-loading-images-from-local-directory","title":"1. Loading images from local directory\u00b6","text":"<p>To load images from a local directory, simply call the <code>load_images</code> function while providing the source directory to read from. Currently, only <code>jpeg</code> images are supported and it is best to provide the full path to the images.</p>"},{"location":"examples/getting-started/#processing-images","title":"Processing Images\u00b6","text":"<p>Now that we have loaded some data, we can perform some simple processing on the images. Check the documentation for the current processing functions available. Here is an example of how <code>landlensdb</code> can be used to snap images to road networks.</p>"},{"location":"examples/getting-started/#snapping-to-a-road-network","title":"Snapping to a Road Network\u00b6","text":"<p>First, we need a road network to snap your images to. <code>landlensdb</code> also offers a helper function to download road networks from Open Street Map within a given bounding box. However, you can also load your own road (or path) network if you have one. We will use our own in this case since these images are taken along an unmapped forest trail.</p>"},{"location":"examples/getting-started/#visualizing-images","title":"Visualizing Images\u00b6","text":"<p><code>landlensdb</code> provides a simple way to visualize its <code>GeoImageFrames</code> interactively using Folium. The <code>map</code> method of a <code>GeoImageFrame</code> will plot all images as markers on a map and will display the image on click along with any metadata set using the <code>additional_properties</code> argument as well as markers for any provided additional geometry.</p>"},{"location":"examples/getting-started/#storing-images","title":"Storing Images\u00b6","text":"<p><code>GeoImageFrame</code> data can be stored in a variety of formats. Given that it is built on GeoPandas the <code>GeoDataFrame</code> class, it will take any geodataframe method to save data. For instance, to save a table as a <code>geopackage</code>, we simply call:</p>"},{"location":"examples/getting-started/#saving-to-a-postgresql-database","title":"Saving to a PostgreSQL Database\u00b6","text":"<p><code>landlensdb</code> also offers functionality to store data in a PostGIS enabled PostgreSQL database. This is done by extending the <code>to_postgis</code> method of GeoPandas. There are some constraints, such as unique image_urls, that are automatically applied when storing data, as well as some data validity checks -- see the documentation for details.</p> <p>To save a <code>GeoImageFrame</code> to a PostgreSQL table, you will need to first initiate a connection to a PostgreSQL database. You can do this using the <code>ImageDB</code> class:</p>"},{"location":"examples/getting-started/#updating-an-existing-table","title":"Updating an Existing Table\u00b6","text":"<p>When saving to PostgreSQL, you can choose to handle existing tables. <code>to_postgis</code> offers the same <code>fail</code>, <code>replace</code> and <code>append</code> methods that GeoPandas offers, however, <code>append</code> requires that all data going in will not conflict with any existing data. Instead, it is possible to \"upsert\" (insert and update) data into existing tables using the <code>upsert_images</code> class method of <code>Image_DB</code>. You may choose to either update conflicting records or skip them by declaring <code>\"update\"</code> or <code>\"nothing\"</code> in the conflict argument of the function.</p>"},{"location":"examples/getting-started/#querying-an-existing-table","title":"Querying an Existing Table\u00b6","text":"<p>It is also possible to load and filter data from existing postgres connections. <code>landlensdb</code> offers simple filter functions to query and filter tables to provide a subset of the data. This can be important when working with very large datasets. For example, to load all images with an altitude greater than 50:</p>"},{"location":"examples/mapillary/","title":"Mapillary","text":"In\u00a0[1]: Copied! <pre>from landlensdb.handlers.cloud import Mapillary\nfrom landlensdb.process.snap import create_bbox, get_osm_lines, snap_to_road_network\nfrom landlensdb.handlers.db import Postgres\nfrom landlensdb.geoclasses.geoimageframe import GeoImageFrame\n</pre> from landlensdb.handlers.cloud import Mapillary from landlensdb.process.snap import create_bbox, get_osm_lines, snap_to_road_network from landlensdb.handlers.db import Postgres from landlensdb.geoclasses.geoimageframe import GeoImageFrame <p>Before we get started, we will need to load our Mapillary API token and other environmental variables. For simplicity, we will use the <code>dotenv</code> library to please install this and create a .env file to follow this tutorial. You will also need to make sure that pandas and geopandas are installed in order to manipulate some of the data required for the tutorial.</p> In\u00a0[2]: Copied! <pre>import os\nimport geopandas as gpd\nimport glob\nimport pandas as pd\n\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nMLY_TOKEN = os.environ.get(\"MLY_TOKEN\")\n</pre> import os import geopandas as gpd import glob import pandas as pd  from dotenv import load_dotenv  load_dotenv()  MLY_TOKEN = os.environ.get(\"MLY_TOKEN\") In\u00a0[3]: Copied! <pre>importer = Mapillary(MLY_TOKEN)\n</pre> importer = Mapillary(MLY_TOKEN) <p><code>landlensdb</code> offers a few functions to filter Mapillary data from their API. However, for more advanced filtering, we recommend that users use the <code>mapillary-python-sdk</code> and convert the resulting data into a GeoImageFrame.</p> <p>Here is an example of how to load data using the <code>fetch_by_id</code> method of <code>landlensdb</code>:</p> In\u00a0[4]: Copied! <pre>image_id = 915374089313107\nimage = importer.fetch_by_id(image_id)\nimage\n</pre> image_id = 915374089313107 image = importer.fetch_by_id(image_id) image Out[4]: altitude atomic_scale camera_parameters camera_type captured_at compass_angle computed_altitude computed_compass_angle computed_geometry computed_rotation ... merge_cc mesh sequence sfm_cluster width detections quality_score mly_id name image_url 0 41.782 1.002665 0.61739578749889,0.26131500830183,0.1242660260... fisheye 2019-10-23T22:29:42+09:00 99.299232 1.795589 102.951814 POINT (140.95153462743 42.329677227362) -1.0627190885041,-0.84029284280692,-1.15538369... ... 1.926644e+18 {'id': '313263440182706', 'url': 'https://scon... emgV_2cwMSoW9w7fkg7xJQ {'id': '169747341731652', 'url': 'https://scon... 4000 {'data': [{'id': '916266259223890'}, {'id': '9... 0.933333 915374089313107 mly|915374089313107 https://scontent.fhnl3-2.fna.fbcdn.net/m1/v/t6... <p>1 rows \u00d7 23 columns</p> <p>By default, <code>landlensdb</code> will download all fields from the Mapillary image endpoint and default to <code>thumb_1024_url</code> as the <code>image_url</code>, however, you may specify a subset of fields using the <code>fields</code> argument and only these fields will be downloaded. Note, you must supply at least the <code>id</code>, <code>geometry</code>, and one of the image url fields.</p> <p>For example, using the <code>fetch_within_bbox</code> method of <code>landlensdb</code>:</p> In\u00a0[20]: Copied! <pre>bbox = [139.59,35.865358, 139.719, 35.882781]\nstart = '2022-03-16'\nend = '2022-03-16'\nfields = ['id', 'altitude', 'captured_at', 'camera_type', 'quality_score', 'thumb_1024_url',\n          'compass_angle', 'computed_compass_angle', 'computed_geometry', 'geometry']\n\nimages = importer.fetch_within_bbox(bbox, start_date=start, end_date=end, fields=fields,\nmax_images=100,# for limiting fetching images\nmax_workers=10)\nimages.head()\n</pre> bbox = [139.59,35.865358, 139.719, 35.882781] start = '2022-03-16' end = '2022-03-16' fields = ['id', 'altitude', 'captured_at', 'camera_type', 'quality_score', 'thumb_1024_url',           'compass_angle', 'computed_compass_angle', 'computed_geometry', 'geometry']  images = importer.fetch_within_bbox(bbox, start_date=start, end_date=end, fields=fields, max_images=100,# for limiting fetching images max_workers=10) images.head() <pre>Fetching 14 tiles...\nReached maximum number of images (100), stopping tile fetching\nFound 3996 total images\nAfter removing duplicates: 3996 unique images\nLimiting to 100 images for processing\n</pre> <pre>Fetching metadata: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:05&lt;00:00, 17.38it/s]\n</pre> Out[20]: altitude captured_at camera_type quality_score compass_angle computed_compass_angle computed_geometry geometry mly_id name image_url 0 38.502000 2022-11-07T01:11:41.352000+09:00 perspective 0.000000 304.154000 308.163758 POINT (139.58766729639 35.888444642159) POINT (139.5877 35.8884) 656828185851650 mly|656828185851650 https://scontent.fhnl3-2.fna.fbcdn.net/m1/v/t6... 1 14.000000 2024-01-19T12:03:23+09:00 perspective 0.000000 306.000000 312.757495 POINT (139.57239765118 35.872508855934) POINT (139.57244 35.87257) 845839730628147 mly|845839730628147 https://scontent.fhnl3-2.fna.fbcdn.net/m1/v/t6... 2 -2.399936 2018-03-18T03:36:35.152000+09:00 perspective 0.764484 310.674866 300.832196 POINT (139.59155887209 35.886212671385) POINT (139.59158 35.88623) 300714221533914 mly|300714221533914 https://scontent.fhnl3-2.fna.fbcdn.net/m1/v/t6... 3 16.115421 2020-02-21T13:46:01.550000+09:00 perspective 0.904487 0.000000 335.390392 POINT (139.57252004801 35.872856102707) POINT (139.57252 35.87285) 165253005445392 mly|165253005445392 https://scontent.fhnl3-2.fna.fbcdn.net/m1/v/t6... 4 54.591000 2024-04-02T09:44:00+09:00 perspective 0.000000 269.794000 276.320324 POINT (139.58541302864 35.877485024935) POINT (139.58543 35.87749) 959520636195873 mly|959520636195873 https://scontent.fhnl3-2.fna.fbcdn.net/m1/v/t6... <p>It is also important to realize that Mapillary image urls are not permanent. So, <code>landlensdb</code> offers a method to download Mapillary images and return a new <code>GeoImageFrame</code> with the updated the <code>image_url</code> to the new location. It is good practice to always use the full path to file locations.</p> In\u00a0[21]: Copied! <pre>relative_path = \"mapillary\"\nabsolute_path = os.path.abspath(relative_path)\n\nimages = images.download_images_to_local(absolute_path, filename_column='name', max_workers=10)\nimages.head()\n</pre> relative_path = \"mapillary\" absolute_path = os.path.abspath(relative_path)  images = images.download_images_to_local(absolute_path, filename_column='name', max_workers=10) images.head() <pre>Downloading images: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:01&lt;00:00, 56.39it/s]\n</pre> Out[21]: altitude captured_at camera_type quality_score compass_angle computed_compass_angle computed_geometry geometry mly_id name image_url 0 38.502000 2022-11-07T01:11:41.352000+09:00 perspective 0.000000 304.154000 308.163758 POINT (139.58766729639 35.888444642159) POINT (139.5877 35.8884) 656828185851650 mly|656828185851650 /Users/iosefa/repos/landlensdb/docs/examples/m... 1 14.000000 2024-01-19T12:03:23+09:00 perspective 0.000000 306.000000 312.757495 POINT (139.57239765118 35.872508855934) POINT (139.57244 35.87257) 845839730628147 mly|845839730628147 /Users/iosefa/repos/landlensdb/docs/examples/m... 2 -2.399936 2018-03-18T03:36:35.152000+09:00 perspective 0.764484 310.674866 300.832196 POINT (139.59155887209 35.886212671385) POINT (139.59158 35.88623) 300714221533914 mly|300714221533914 /Users/iosefa/repos/landlensdb/docs/examples/m... 3 16.115421 2020-02-21T13:46:01.550000+09:00 perspective 0.904487 0.000000 335.390392 POINT (139.57252004801 35.872856102707) POINT (139.57252 35.87285) 165253005445392 mly|165253005445392 /Users/iosefa/repos/landlensdb/docs/examples/m... 4 54.591000 2024-04-02T09:44:00+09:00 perspective 0.000000 269.794000 276.320324 POINT (139.58541302864 35.877485024935) POINT (139.58543 35.87749) 959520636195873 mly|959520636195873 /Users/iosefa/repos/landlensdb/docs/examples/m... Out[21]: altitude captured_at camera_type compass_angle computed_compass_angle computed_geometry geometry mly_id name image_url quality_score 0 14.768889 2020-02-21T13:44:34.569000+09:00 perspective 9.554391 351.504697 POINT (139.57339081065 35.871402809966) POINT (139.5734 35.87141) 864971387703143 mly|864971387703143 test_images/downloads/mly|864971387703143.jpg 0.7 1 16.000000 2024-01-19T12:01:50+09:00 perspective 247.000000 310.752912 POINT (139.57289114328 35.87219131719) POINT (139.57279 35.87224) 336839779179779 mly|336839779179779 test_images/downloads/mly|336839779179779.jpg 0.7 2 48.680551 2020-08-01T12:01:21.643000+09:00 perspective 358.808411 1.589768 POINT (139.58462410187 35.883294681154) POINT (139.58463 35.8833) 5653252761383733 mly|5653252761383733 test_images/downloads/mly|5653252761383733.jpg 0.7 3 11.000000 2024-01-19T12:04:53+09:00 perspective 246.000000 55.156704 POINT (139.57205573147 35.872939770667) POINT (139.57206 35.87295) 344214351810374 mly|344214351810374 test_images/downloads/mly|344214351810374.jpg 0.7 4 9.022069 2020-03-09T13:32:58.202000+09:00 perspective 194.887604 168.303653 POINT (139.58402274235 35.877453641423) POINT (139.58415 35.87735) 508816543794292 mly|508816543794292 test_images/downloads/mly|508816543794292.jpg 0.7 In\u00a0[7]: Copied! <pre>bbox = images['geometry'].total_bounds\nnetwork = get_osm_lines(bbox)\n</pre> bbox = images['geometry'].total_bounds network = get_osm_lines(bbox) <p>Then, calling the <code>snap_to_road_network</code> will snap all points to the closest road network (within the provided threshold distance) and will create a new geometry column in the <code>GeoImageFrame</code> falled <code>snapped_geometry</code> to represent this new point.</p> In\u00a0[8]: Copied! <pre>snap_to_road_network(images, 100, network)\n</pre> snap_to_road_network(images, 100, network) <pre>/Users/iosefa/repos/landlensdb/landlensdb/process/snap.py:232: UserWarning: \n        Not all images were snapped. Non-snapped images will not be added \n        to the snapped image table. To snap all images, try increasing the threshold \n        or changing the road network. The following images could not be snapped \n        to a road network: ['/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|341189448731335.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|2894556887433291.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|845839730628147.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|165253005445392.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|1578427066239162.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|4073999156023160.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|2022903504790710.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|798037910842482.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|321170896035731.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|135578586316907.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|977004729506385.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|151439446992900.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|366394412691407.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|2196359430499964.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|1074933626880597.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|259857353794309.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|1780421159052050.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|470266004254253.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|739435500086975.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|3529384387315502.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|344214351810374.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|7037649352990242.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|284181453385106.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|1348429235810254.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|163483822448611.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|266023851890350.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|882539549271017.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|250040466902808.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|298938741783046.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|463760911393728.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|1083992052788441.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|489004355634199.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|958784518225045.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|146933804077187.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|3877177859055675.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|1138747620595199.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|841487969775838.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|398261285903268.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|7275967072425300.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|1400369537274529.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|309864044006486.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|243705220835241.jpg', '/Users/iosefa/repos/landlensdb/docs/examples/mapillary/mly|178622602000292.jpg']\n        \n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/process/snap.py:129: UserWarning: \n            GeodataImageFrame contains rows with empty snapped_geometry. Non-snapped images will be skipped.\n            To snap all images, try increasing the threshold or changing the road network.\n            \n  warnings.warn(\n</pre> Out[8]: altitude captured_at camera_type compass_angle computed_compass_angle computed_geometry geometry mly_id name image_url quality_score snapped_geometry snapped_angle 0 5.157323 2020-05-17T09:34:25.224000+09:00 perspective 345.032135 64.252294 POINT (139.58263261308 35.877839236796) POINT (139.58263 35.87783) 299088425109738 mly|299088425109738 /Users/iosefa/repos/landlensdb/docs/examples/m... 0.7 POINT (139.58263 35.87784) 247.485127 1 38.502000 2022-11-07T01:11:41.352000+09:00 perspective 304.154000 308.163758 POINT (139.58766729639 35.888444642159) POINT (139.5877 35.8884) 656828185851650 mly|656828185851650 /Users/iosefa/repos/landlensdb/docs/examples/m... 0.7 POINT (139.5877 35.8884) 304.460467 2 54.591000 2024-04-02T09:44:00+09:00 perspective 269.794000 276.320324 POINT (139.58541302864 35.877485024935) POINT (139.58543 35.87749) 959520636195873 mly|959520636195873 /Users/iosefa/repos/landlensdb/docs/examples/m... 0.7 POINT (139.58543 35.87748) 268.479139 3 12.000000 2024-01-19T12:04:21+09:00 perspective 319.000000 330.582321 POINT (139.57227883013 35.872625965843) POINT (139.57232 35.87267) 341189448731335 mly|341189448731335 /Users/iosefa/repos/landlensdb/docs/examples/m... 0.7 None NaN 4 5.500537 2020-05-17T09:28:41.965000+09:00 perspective 343.608521 81.007946 POINT (139.57913973808 35.876375848152) POINT (139.57815 35.87591) 2894556887433291 mly|2894556887433291 /Users/iosefa/repos/landlensdb/docs/examples/m... 0.7 None NaN ... ... ... ... ... ... ... ... ... ... ... ... ... ... 95 14.880390 2020-02-21T13:44:53.100000+09:00 perspective 331.856595 336.501893 POINT (139.57314536276 35.871769469654) POINT (139.57314 35.87174) 309864044006486 mly|309864044006486 /Users/iosefa/repos/landlensdb/docs/examples/m... 0.7 None NaN 96 4.887280 2020-05-17T09:19:59.208000+09:00 perspective 353.266785 335.405193 POINT (139.57910854058 35.872199360711) POINT (139.57911 35.8722) 243705220835241 mly|243705220835241 /Users/iosefa/repos/landlensdb/docs/examples/m... 0.7 None NaN 97 7.213029 2020-05-17T09:41:26.497000+09:00 perspective 90.242986 84.969101 POINT (139.58843748084 35.879393276315) POINT (139.58844 35.87939) 520722175762090 mly|520722175762090 /Users/iosefa/repos/landlensdb/docs/examples/m... 0.7 POINT (139.58844 35.8794) 88.965971 98 10.585542 2020-03-09T13:34:18.698000+09:00 perspective 214.312256 75.909129 POINT (139.58375978158 35.878759370556) POINT (139.58361 35.87855) 956597638469064 mly|956597638469064 /Users/iosefa/repos/landlensdb/docs/examples/m... 0.7 POINT (139.58372 35.8786) 150.474872 99 10.000000 2024-01-19T12:18:53+09:00 perspective 224.000000 26.167133 POINT (139.57051706948 35.872654878585) POINT (139.5705 35.87266) 178622602000292 mly|178622602000292 /Users/iosefa/repos/landlensdb/docs/examples/m... 0.7 None NaN <p>100 rows \u00d7 13 columns</p> In\u00a0[9]: Copied! <pre>images.map(\n    additional_properties=['altitude', 'camera_type'],\n    additional_geometries=[\n        {'geometry': 'computed_geometry', 'angle': 'computed_compass_angle', 'label': 'Computed'},\n        {'geometry': 'snapped_geometry', 'angle': 'snapped_angle', 'label': 'Snapped'},\n    ]\n)\n</pre> images.map(     additional_properties=['altitude', 'camera_type'],     additional_geometries=[         {'geometry': 'computed_geometry', 'angle': 'computed_compass_angle', 'label': 'Computed'},         {'geometry': 'snapped_geometry', 'angle': 'snapped_angle', 'label': 'Snapped'},     ] ) <pre>/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 3 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 4 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 5 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 7 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 8 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 11 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 12 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 21 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 23 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 27 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 30 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 31 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 32 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 33 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 35 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 37 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 38 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 44 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 45 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 47 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 48 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 51 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 54 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 55 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 56 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 60 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 63 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 64 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 66 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 67 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 69 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 72 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 73 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 79 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 81 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 82 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 84 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 87 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 89 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 94 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 95 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 96 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n/Users/iosefa/repos/landlensdb/landlensdb/geoclasses/geoimageframe.py:442: UserWarning: Item at index 99 in 'snapped_geometry' is not a valid Point. Skipping.\n  warnings.warn(\n</pre> Out[9]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[22]: Copied! <pre>images.to_file('images_tutorial.gpkg')\n</pre> images.to_file('images_tutorial.gpkg') <p>However, in the current version when reading a saved vector format it is important to then initialize the GeoDataFrame as a GeoImageFrame if you want to make use of the features of <code>landlensdb</code>. For example:</p> In\u00a0[25]: Copied! <pre>images_gdf = gpd.read_file('images_tutorial.gpkg')\nimages = GeoImageFrame(images_gdf)\n</pre> images_gdf = gpd.read_file('images_tutorial.gpkg') images = GeoImageFrame(images_gdf) In\u00a0[14]: Copied! <pre>db_con = Postgres('postgresql://localhost:5432/landlens')\n</pre> db_con = Postgres('postgresql://localhost:5432/landlens') <p>This database must already exist and have PostGIS loaded.</p> <p>Then, you can save using <code>to_postgis</code>:</p> In\u00a0[15]: Copied! <pre>images.to_postgis('tutorial', db_con.engine, if_exists=\"replace\")\n</pre> images.to_postgis('tutorial', db_con.engine, if_exists=\"replace\") In\u00a0[16]: Copied! <pre>db_con.upsert_images(images, 'tutorial', conflict='update')\n</pre> db_con.upsert_images(images, 'tutorial', conflict='update') In\u00a0[18]: Copied! <pre>high_altitude_images = db_con.table('tutorial').filter(altitude__gt=50).all()\n\nhigh_alt_map = high_altitude_images.map(\n    additional_properties=['altitude', 'camera_type'],\n    additional_geometries=[\n        {'geometry': 'geometry', 'angle': 'compass_angle', 'label': 'Base Geometry'},\n    ])\nhigh_alt_map.save('query_map.html')\n</pre> high_altitude_images = db_con.table('tutorial').filter(altitude__gt=50).all()  high_alt_map = high_altitude_images.map(     additional_properties=['altitude', 'camera_type'],     additional_geometries=[         {'geometry': 'geometry', 'angle': 'compass_angle', 'label': 'Base Geometry'},     ]) high_alt_map.save('query_map.html') In\u00a0[19]: Copied! <pre>high_alt_map\n</pre> high_alt_map Out[19]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/mapillary/#working-with-mapillary-data","title":"Working with Mapillary Data\u00b6","text":"<p>This short notebook demostrates how <code>landlensdb</code> can be used to load, process, visualize, and store street-view data from Mapillary servers.</p>"},{"location":"examples/mapillary/#pre-requisites","title":"Pre-requisites\u00b6","text":"<p>Before getting started, you will need to have PostgreSQL and PostGIS installed.</p>"},{"location":"examples/mapillary/#postgresql-and-postgis","title":"PostgreSQL and PostGIS\u00b6","text":"<p>Once PostgreSQL and PostGIS are installed, or if they are already installed, then you will need to have a PostGIS enabled PostgreSQL database to work with. To create one, use:</p> <pre>createdb &lt;database_name&gt; &amp;&amp; psql &lt;database_name&gt; -c \"CREATE EXTENSION POSTGIS\"\n</pre> <p>Be sure to replace <code>&lt;database_name&gt;</code> with the name you want to call your database. For example, it could be:</p> <pre>createdb landlens &amp;&amp; psql landlens -c \"CREATE EXTENSION POSTGIS\"\n</pre>"},{"location":"examples/mapillary/#mapillary-token","title":"Mapillary Token\u00b6","text":"<p>You will also need to have a Mapillary API token. This isnt necessary to use the library, but you will need it to follow the tutorial, which includes examples on connecting to Mapillary and downloading images.</p>"},{"location":"examples/mapillary/#env-file","title":".env File\u00b6","text":"<p>Finally, you will need to save this information into a <code>.env</code> file. To create a <code>.env</code> file, use:</p> <pre>touch .env\n</pre> <p>Then, paste the following:</p> <pre><code>MLY_TOKEN=&lt;token&gt;\n</code></pre> <p>Replace the text enclosed by angular brackets <code>&lt;&gt;</code> with the actual text. For example, your <code>MLY_TOKEN</code> would be the Mapillary token you can acquire from a Mapillary account. Usually, these start with <code>MLY|</code>. The path variables are absolute paths to where you want files to be read or written. The database URL, if the database was created using the earlier instructions, would look like: <code>postgresql://localhost:5432/landlens</code>, assuming PostgreSQL is being served on localhost with port 5432 (the default). The <code>DB_TABLE</code> will be the table name to use in this tutorial. It can be anything, for example: <code>mapillary_images</code>.</p> <p>Once this is done, you should be ready to proceed with the tutorial.</p> <p>If you don't have <code>landlens_db</code> installed, you can do so with <code>pip install landlensdb</code>.</p>"},{"location":"examples/mapillary/#loading-images-from-mapillary","title":"Loading Images from Mapillary\u00b6","text":"<p><code>landlensdb</code> was made to work with Mapillary data and it includes helper functions to make calls to the Mapillary API and download and convert Mapillary data into a format for <code>landlensdb</code>.</p> <p>To use <code>landlensdb</code> to fetch data from Mapillary, you first need to initialize a Mapillary connection using your Mapillary Secret Token.</p>"},{"location":"examples/mapillary/#loading-data-from-arbitrary-sources","title":"Loading data from arbitrary sources\u00b6","text":"<p>It is also possible to read from any OGC-recognized vector file format, including ESRI shapefile, geojson, and geopackage, or to create a <code>GeoImageFrame</code> in the same manner as a geopandas dataframe by initializing it with data so long as it has a <code>name</code>, <code>image_url</code>, and <code>geometry</code> column.</p> <p>Data can also be imported from a PostreSQL postGIS enabled database. There is more information below on creating and exporting postgres tables for <code>landlensdb</code>.</p> <p>When reading from postgres, it can be beneficial to load a subset of data. This can be important when the database contains upwards of tens of thousands of images. For this purpose, there are several database utility and query functions to select only a subset of the data in the database.</p>"},{"location":"examples/mapillary/#processing-images","title":"Processing Images\u00b6","text":"<p>Now that we have loaded some data, we can perform some simple processing on the images. Check the documentation for the current processing functions available. Here is an example of how <code>landlensdb</code> can be used to snap images to road networks.</p> <p>First, we need a road network to snap your images to. <code>landlensdb</code> also offers a helper function to download road networks from Open Street Map within a given bounding box.</p>"},{"location":"examples/mapillary/#snapping-to-a-local-road-network","title":"Snapping to a local road network\u00b6","text":"<p>It is also possible to load your own road network and snap to this. When doing this, it is important that all the image points are within a reasonable distance from any given road in your network and that the threshold is appropriately set. If you suspect that there are images far from a road, and you do need that image to be snapped to the closest road, then be sure to set a high enough threshold.</p> <p>Here is an example of how this can be achieved:</p> <pre>roads_path = 'data/roads/*.shp'\nroad_files = glob.glob(roads_path)\nroads = [gpd.read_file(road) for road in road_files]\nnetwork = pd.concat(roads, ignore_index=True)\nsnap_to_road_network(images, 100, network, realign_camera=True)\n</pre>"},{"location":"examples/mapillary/#visualizing-images","title":"Visualizing Images\u00b6","text":"<p><code>landlens_db</code> provides a simple way to visualize its <code>GeoImageFrames</code> interactively using Folium. The <code>map</code> method of a <code>GeoImageFrame</code> will plot all images as markers on a map and will display the image on click along with any metadata set using the <code>additional_properties</code> argument as well as markers for any provided additional geometry.</p>"},{"location":"examples/mapillary/#storing-images","title":"Storing Images\u00b6","text":"<p><code>GeoImageFrame</code> data can be stored in a variety of formats. Given that it is built on GeoPandas the <code>GeoDataFrame</code> class, it will take any geodataframe method to save data. For instance, to save a table as a <code>geopackage</code>, we simply call:</p>"},{"location":"examples/mapillary/#saving-to-a-postgresql-database","title":"Saving to a PostgreSQL Database\u00b6","text":"<p><code>landlens_db</code> also offers functionality to store data in a PostGIS enabled PostgreSQL database. This is done by extending the <code>to_postgis</code> method of GeoPandas. There are some constraints, such as unique image_urls, that are automatically applied when storing data, as well as some data validity checks -- see the documentation for details.</p> <p>To save a <code>GeoImageFrame</code> to a PostgreSQL table, you will need to first initiate a connection to a PostgreSQL database. You can do this using the <code>ImageDB</code> class:</p>"},{"location":"examples/mapillary/#updating-an-existing-table","title":"Updating an Existing Table\u00b6","text":"<p>When saving to PostgreSQL, you can choose to handle existing tables. <code>to_postgis</code> offers the same <code>fail</code>, <code>replace</code> and <code>append</code> methods that GeoPandas offers, however, <code>append</code> requires that all data going in will not conflict with any existing data. Instead, it is possible to \"upsert\" (insert and update) data into existing tables using the <code>upsert_images</code> class method of <code>Image_DB</code>. You may choose to either update conflicting records or skip them by declaring <code>\"update\"</code> or <code>\"nothing\"</code> in the conflict argument of the function.</p>"},{"location":"examples/mapillary/#querying-an-existing-table","title":"Querying an Existing Table\u00b6","text":"<p>It is also possible to load and filter data from existing postgres connections. <code>landlensdb</code> offers simple filter functions to query and filter tables to provide a subset of the data. This can be important when working with very large datasets. For example, to load all images with an altitude greater than 50:</p>"}]}